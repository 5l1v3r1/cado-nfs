/*****************************************************************************/
/*                   to generate our factoring methods                       */
/*****************************************************************************/

Some binaries are available in this directory :
  1- gfm
  2- benchfm
  3- gst
  4- finalst
Firstly, gfm allows to choose the optimal parameters (B1, B2) for each
factoring methods (PM1, PP1-27, PP1-65, ECM-M12, ECM-M16, ECM-B12) to
find a prime number in [2^lb, 2^ub]. Potentially, there are innumerable
couples of parameters.

So, you can specify the sieve region that you want to test with several
options:
   - b1min, b1_max, b1step
   - cmin, cmax, cstep (where c equal to B2/B1).

Now, you have got your optimal parameters for each type of factoring
methods for different intervals of prime numbers. In the context of the
sieving step, the goal is to define strategies to find quickly the most
relations. Before choosing these strategies, you must do a benchmark over
your factoring methods to know exatly what is the probability and the cost
to find a prime number of certain bit size.

To do this, the binary benchfm is available. In input, you give a file
with factoring methods, and you can compute the probabilities and/or
the time for each one of them.

TODO: a filter is doing to allow to keep only a number of factoring methods!!!


file format :
-------------
m c B1 B2 | p propa_p proba_(p+1) ...  | c1 c2 c3 c4 |
etc... one line equals to one factoring method.
where:
  - m denotes a type of method and c denotes the curve
    (PM1=1 0, PP1-27=2 0, PP1-65=3 0, ECM-M12=4 1, ECM-M16=4 2, ECM-B12=4 0)
  - B1 et B2 are the parameters of the factoring method.
  - p is the bit size of prime number that we start to bench
  - p_i is the probabiliy to find a prime number of i bits size.
  - ci is the runtime for various input sizes:
(c1 (resp. c2 c3 c4) for an integer to MODREDCUL_MAXBITS, (resp. 
MODREDC15UL_MAXBITS, MODREDC2UL2_MAXBITS and MODREDC2UL2_MAXBITS+30) bits size.

In what follows, we give usage examples:

For examples, you could search optimal parameters with:
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 100 -b1max 500 -b1step 50 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_1
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 500 -b1max 2000 -b1step 50 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_2
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 2000 -b1max 5000 -b1step 100 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_3

Then, we concatenate our data, and compute the convex hull:
cat Data_PM1_1 Data_PM1_2 Data_PM1_3 > Data_PM1
./gfm -fch -fch_in Data_PM1 -fch_out Data_PM1_ch

Finally, to bench the found methods, you can use the following command :
./benchfm -in Data_PM1_ch -p -t -out Data_PM1_ch_pt

Note that these commands are just an example to illustrate the different
usages of our binaries.


/*****************************************************************************/
/*                       to generate our strategies                          */
/*****************************************************************************/

Now, you have generated our factoring methods, but you must chain them
to optain the best performances. In order to do that, we can use the
binary gst to build the optimal strategies for each pair of bit
lengths. 
 This program works firstly side by side. On each side, for
each bit size of cofactor, you generate many strategies and keep only
the best ones. After these different computations, it merges them to
generate on each pair of cofactors the best strategies to find 
a prime divisor.

In what follows, we give an example to illustrate a procedure to
achieve our objective:

Firsly, you should precompute all decompositions of cofactors of less than mfb
bits given that  it has no prime divisors less than fbb. To do it, assuming you
have created a directory decomp_tmp/:

./gst -gdc -fbb0 20 -mfb0 39 -out decomp_tmp/decomp_20_39
# Note the product of two 20-bit primes can have 39 or 40 bits
./gst -gdc -fbb0 20 -mfb0 40 -out decomp_tmp/decomp_20_40
cat decomp_tmp/decomp_20_40
[ 20, 20 ] : 451299262.762625
[ 20, 21 ] : 1122087524.990350
./gst -gdc -fbb0 20 -mfb0 41 -out decomp_tmp/decomp_20_41
./gst -gdc -fbb0 20 -mfb0 42 -out decomp_tmp/decomp_20_42
./gst -gdc -fbb0 20 -mfb0 43 -out decomp_tmp/decomp_20_43
etc ... until mfb!

Secondly, you should distribute the precomputation of strategies for each
size and side. An example is given by the script script_str_r.sh

Remark: the files results are stored in the directory 'out' and the format
name of files is: strategies_$fbb_$r, where fbb is the bit size of the
factor base bound and r the bit size of the cofactor).

Then, you merge our results to compute the matrix which stores the
differents strategies for each pair of bit size (see the script
'script_str.sh').

Remark: The format name of files is: strategies_r0_r1, where r0 and r1
are the bit size of the studied pair of cofactors (r0,r1).

Note that: Without options '-gst' or '-gst_r' the binary 'gst' compute
our matrix of strategies without precompution in several files. For
more information, see the function generate_matrix() in
generate_strategies.c.


Note that these different steps stored their results in a file with
the following format:
m  c  b1  b2  side
m' c' b1' b2' side' 
etc...
probability: p
time: t
etc ... for each strategy.

with: m the factoring method
      c the curve
      b1 and b2 the parameters
      side is the side where one applies this factoring method.
      p and t the probability and the time to find a non
      trivial factor in our cofactor.


/******************************************************************************/
/*                        to find THE good strategy                           */
/******************************************************************************/
Now, we have for each pair of cofactors (r0,r1) a set of
strategies. But the question is : Which strategy shall we use to
factor (r0,r1) ?  In order to reply to that question, we have used
Kleinjung's observations (see his article named 'Cofactorisation
strategies for the number Field sieve and an estimate for the sieving
step for factoring 1024-bit integers');

To do that, the binary 'finalst' is available.  

./finalst -st res_matrix/ -dist file_dec -t 6875 -mfb0 110 -mfb1 110 -out final_st

Where: res_matrix/ is the directory which contains our strategies.
       file_dec    is a file generated by cado-nfs containing the distribution 
       of our cofactors pairs.
       -t 6875  is the time (seconds) which allows to compute the previous file.


file format for our result 'final_st':
-----------
For each bit-size pair (r0,r1) which is called in CADO, you have for example:

[r0=1, r1=61] : (p = 0.999446, t = 483.845263)
[ S1: PM1, 950, 123500 ] [ S1: PP1-65, 975, 107250 ] [ S1: ECM-M16, 600, 144000 ]
[ S1: ECM-M12, 600, 168000 ] [ S1: ECM-M12, 600, 168000 ] 
[ S1: ECM-M12, 600, 168000 ] [ S0: ECM-B12, 0, 0 ]

where: 

(r0,r1) specify the bit-size of cofactors.  

p is the probability to find a relation with this strategy 
and t the average runtime.  

And each [S: m, b1, b2] is a factoring method given by the
method m and these parameters b1 and b2, and S is the side where
this factoring method is apply (S0 for r0 and S1 for r1).
