Two binaries are available in this directory :
  1- gfm
  2- benchfm

Firstly, gfm allows to choose the optimal parameters (B1, B2) for each
factoring methods (PM1, PP1-27, PP1-65, ECM-M12, ECM-M16, ECM-B12) to
find a prime number in [2^lb, 2^ub]. Potentially, there are innumerable
couples of parameters.

So, you can specify the sieve region that you want to test with several
options:
   - b1min, b1_max, b1step
   - cmin, cmax, cstep (where c equal to B2/B1).

Now, you have got your optimal parameters for each type of factoring
methods for different intervals of prime numbers. In the contex of the
sieving step, the goal is to define strategies to find quickly the most
relations. Before choosing these strategies, you must do a benchmark over
our factoring methods to know exatly what is the probability and the cost
to find a prime number of certain bit size.

To do this, the binary benchfm is available. In input, you give a file
with factoring methods, and you could compute the probabilities and/or
the time for each one of them.

TODO: a filter is doing to allow to keep only a number of factoring methods!!!


file format :
-------------
m c B1 B2 | p propa_p proba_(p+1) ...  | c1 c2 c3 c4 |
etc... one line equals to one factoring method.
where:
  - m denotes a type of method.
  - c denotes the curve.
  - B1 et B2 are the parameters of the factoring method.
  - p is the bit size of prime number that we start to bench
  - p_i is the probabiliy to find a prime number of i bits size.
  - ci is the runtime for various input sizes:
(c1 (resp. c2 c3 c4) for an integer to MODREDCUL_MAXBITS, (resp. 
MODREDC15UL_MAXBITS, MODREDC2UL2_MAXBITS and 3*MODREDCUL_MAXBITS) bits size.

In what follows, we give usage examples :

For examples, you could search optimal parameters with:
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 100 -b1max 500 -b1step 50 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_1
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 500 -b1max 2000 -b1step 50 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_2
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 2000 -b1max 5000 -b1step 100 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_3

Then, we concatenate our datas, and compute the convex hull:
cat Data_PM1_1 Data_PM1_2 Data_PM1_3 > Data_PM1
./gfm -fch -fch_in Data_PM1 -fch_out Data_PM1_ch

Finally, to bench the found methods, you could use the following command :
./benchfm -in Data_PM1_ch -p -t -out Data_PM1_ch_pt

Note that these commands are just an example to illustrate the differents
usefullness of our binaries.
