/******************************************************************************/
/*                    to generate our factoring methods                       */
/******************************************************************************/

Two binaries are available in this directory :
  1- gfm
  2- benchfm

Firstly, gfm allows to choose the optimal parameters (B1, B2) for each
factoring methods (PM1, PP1-27, PP1-65, ECM-M12, ECM-M16, ECM-B12) to
find a prime number in [2^lb, 2^ub]. Potentially, there are innumerable
couples of parameters.

So, you can specify the sieve region that you want to test with several
options:
   - b1min, b1_max, b1step
   - cmin, cmax, cstep (where c equal to B2/B1).

Now, you have got your optimal parameters for each type of factoring
methods for different intervals of prime numbers. In the contex of the
sieving step, the goal is to define strategies to find quickly the most
relations. Before choosing these strategies, you must do a benchmark over
our factoring methods to know exatly what is the probability and the cost
to find a prime number of certain bit size.

To do this, the binary benchfm is available. In input, you give a file
with factoring methods, and you could compute the probabilities and/or
the time for each one of them.

TODO: a filter is doing to allow to keep only a number of factoring methods!!!


file format :
-------------
m c B1 B2 | p propa_p proba_(p+1) ...  | c1 c2 c3 c4 |
etc... one line equals to one factoring method.
where:
  - m denotes a type of method.
  - c denotes the curve.
  - B1 et B2 are the parameters of the factoring method.
  - p is the bit size of prime number that we start to bench
  - p_i is the probabiliy to find a prime number of i bits size.
  - ci is the runtime for various input sizes:
(c1 (resp. c2 c3 c4) for an integer to MODREDCUL_MAXBITS, (resp. 
MODREDC15UL_MAXBITS, MODREDC2UL2_MAXBITS and 3*MODREDCUL_MAXBITS) bits size.

In what follows, we give usage examples :

For examples, you could search optimal parameters with:
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 100 -b1max 500 -b1step 50 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_1
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 500 -b1max 2000 -b1step 50 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_2
./gfm -m PM1 -lb 20 -ub 25 -n 150 -b1min 2000 -b1max 5000 -b1step 100 -cmin 10 -cmax 200 -cstep 10 -out Data_PM1_3

Then, we concatenate our datas, and compute the convex hull:
cat Data_PM1_1 Data_PM1_2 Data_PM1_3 > Data_PM1
./gfm -fch -fch_in Data_PM1 -fch_out Data_PM1_ch

Finally, to bench the found methods, you could use the following command :
./benchfm -in Data_PM1_ch -p -t -out Data_PM1_ch_pt

Note that these commands are just an example to illustrate the differents
usefullness of our binaries.


/******************************************************************************/
/*                        to generate our strategies                          */
/******************************************************************************/

Now, you have generated our factoring methods, but you must chain them
to optain the best performances. In order to do that, we can use the
binary gst to build the optimal strategies for each pair of bit
lengths. 
 This program works firstly side by side. On each side, for
each bit size of cofactor, you generate many strategies and keep only
the bests. After these differents computations, it merges them to
generate on each pair of cofactors the best strategies to find 
a prime divisor.

In what follows, you give an example to illustrate a procedure to
achieve our objective:

Firstly, you can distribute the precomputation of strategies for each
size and side: (see the script (coming days)):

./gst -gst_r -lpb0 $lpb0 -fbb0 $fbb0 -r $r0 -in $methods -decomp $pathname_decomp -out $out &

(the files results are stored in the directory 'out' and the format
name of files is: strategies_fbb_r, where fbb is the bit size of
factor base bound and r the bit size of the cofactor).

Then, you merge our results to compute the matrix which store the
differents strategies for each pair of bit size (see the script
(coming days)):

./gst -gst -mfb0 $mfb0 -fbb0 $fbb0 -mfb1 $mfb1 -fbb1 $fbb1 -r0 $r0 -r1 $r1 -in $in -out $out &

(the files results are stored in the directory 'out' and the format
name of files is: strategies_r0_r2, where r0 and r1 are the bit size
of the studied pair of cofactors.)


Note that: Without options '-gst' or '-gst_r' the binary 'gst' compute
our matrix of strategies without precompution in several files. For
more informmation, see the function generate_matrix() in
generate_strategies.c.


Note that these different steps stored their results in a file with
the following format:
m  c  b1  b2  side
m' c' b1' b2' side' 
etc...
probability: p
time: t
etc ... for each strategy.

with: m the factoring method
      c the curve
      b1 and b2 the parameters
      side is the side where you apply this factoring method.
      p and t the probability and the time to find a non
      trivial factor in our cofactor.

These files are also a format name according the used option: 
-gst_r the file name is 'strategies_**_++ where: ** is equal to fbb 
       and ++ the bit size of cofactor.  
-gst_r the file name is 'strategies_**_++ where: ** is equal to the bit
 size of the first cofactor r0 and ++ for the second.


/******************************************************************************/
/*                        to find THE good strategy                           */
/******************************************************************************/
Now, we have for each pair of cofactors (r0,r1) a set of
strategies. But the question is : Which strategy shall we use to
factor (r0,r1) ?  In order to reply to that question, we have used
Kleinjung's observations (see his article named 'Cofactorisation
strategies for the number Field sieve and an estimate for the sieving
step for factoring 1024-bit integers');

To do that, the binary 'finalst' is available.  

./finalst -st res_matrix/ -dist file_dec -t 6875 -mfb0 110 -mfb1 110 -out final_st

Where: res_matrix/ is the directory which contains our strategies.
       file_dec    is a file generated by cado-nfs containing the distribution 
       of our cofactors pairs.
       -t 6875  is the time (seconds) which allows to compute the previous file.


file format for our result 'final_st':
-----------
For each bit-size pair (r0,r1) which is called in CADO, you have for example:

[r0=1, r1=61] : (p = 0.999446, t = 483.845263)
[ S1: PM1, 950, 123500 ] [ S1: PP1-65, 975, 107250 ] [ S1: ECM-M16, 600, 144000 ]
[ S1: ECM-M12, 600, 168000 ] [ S1: ECM-M12, 600, 168000 ] 
[ S1: ECM-M12, 600, 168000 ] [ S0: ECM-B12, 0, 0 ]

where: 

(r0,r1) specify the bit-size of cofactors.  

p is the probability to find a relation with this strategy 
and t the average runtime.  

And each [S: m, b1, b2] is a factoring method given by the
method m and these parameters b1 and b2, and S is the side where
this factoring method is apply (S0 for r0 and S1 for r1).