Binaries for NFS, NFS-DL, FFS
=============================

NFS   : dup1   -> dup2           -> purge -> merge    -> replay
NFS-DL: dup1   -> dup2           -> purge -> merge-dl -> replay-dl
FFS   : dup1 * -> dup2-ffs-f? ** -> purge -> merge-dl -> replay-dl

*with -abhexa command line option
**? is the caracteristic (currently only 2 or 3)

Relations format
================

purge, merge, merge-dl, replay-dl read relations in the following format:
  a,b:i1,...,ik
  where a and b are in hexa
        i1,...,ik are indexes in the renumbering table
  all appearances of the same index must be continuous

dup1 (without -abhexa) reads relations in the following format (output of las)
  a,b:p1,...,pl:p'1,...,p'r
  where a and b are in basis 10
        p1,...,pl,p'1,...,p'r are in hexa

dup1 (with -abhexa) reads relations in the following format (output of sieve4ffs)
  a,b:p1,...,pl:p'1,...,p'r
  where a and b are in hexa
        p1,...,pl,p'1,...,p'r are in hexa

dup2 reads relations in two different format (deducted by reading the first line
of the file): either the same as purge, merge, merge-dl, ...; either the same
as dup1 without abhexa

dup-ffs-f* reads relations in two different format (deducted by reading the
first line of the file): either the same as purge, merge, merge-dl, ...; either
the same as dup1 with abhexa

File XXX.renumber
==============

It contains the table that links an ideal (p on rational side, (p,r) on
algebraic side) to its index that going to be used during filtering.

The first line has the following format:
nbits size nbad add
where
  - nbits is 32 or 64 (depending on the maximum value of p possible, ie the large
    prime bounds).
  - size is the number of ideal in the table.
  - nbad is the number of bad ideals (should be 0 for factorization)
  - add is 0 or 1 (should be 0 for factorization). If add is 1, a column is
    added to the matrix. It is usefull to take into account the logarithm of J
    ideal for DL.
nbits, size, nbad and add are written in decimal.

Then, the file contains nbad line of the following format:
p,r:s: n
where
  - p is a prime and 0 <= r < p such that (p,r) is a bad ideal.
  - s is the side (0 or 1) on which this bad ideal may appear.
  - n is the number of ideals above this bad ideal.
p and r are written in hexadecimal, side an nb is written in decimal.

At last, the file contains the renumbering table (one hexadecimal number per
line).

File XXX.purged.gz
==================

It is created by purge, and contains a set of relations without
singleton, and where all or almost all the excess has been used.

The first line has the following format:
# nr lc nc
where
  - nr is the number of rows (relations)
  - lc is the index of the last column (ideal) that has non-zero weight
  - nc is the number of columns (ideals)
nr, lc and nc are written in decimal.

Then, each line of the file corresponds to one relation: a,b:h_0,....h_k
where
  - a and b give the (a,b) pair of the original relation
  - h_i is an index of an ideal appearing in the relation. For factorization, an
    ideal appears at most one per relation. For DL, if an ideal more than
    once in the relation, all these occurences are guaranteed to be one after
    the other.
a,b and the h_i's are in hexadecimal.

File XXX.rels.deleted.gz
==================

It is created by purge, and contains all the relations that purge deleted.
It has the same format as XXX.purged.gz except the first line which does not
exist in the XXX.rels.deleted.gz file.
Usefull only for DL.


File XXX.merge.his
==================

It is created by merge, and contains the sequence of operations that must
be done on the lines to replay the merge and create the matrix given to
linalg.

The first line gives number of rows (relations) and columns (ideals)
before the merge (so it must be identical to the first line of
purged.gz).

From time to time, a diagnostic line starting with BWCOST can be found.
It gives hints to replay if it wants to replay only some part of the
merge. (is it still really used ?????)

Otherwise here is the format (taken from a comment in replay.c):
   A line is "i i1 ... ik".
   If i >= 0 then
       row[i] is to be added to rows i1...ik and destroyed at the end of
       the process.
       Works also is i is alone (hence: destroyed row).
   If i < 0 then
       row[-i-1] is to be added to rows i1...ik and NOT destroyed.

For DL, the line ends with an additional "#j" entry, where j
is the index of the column that is used for pivoting.

File XXX.ideal
==============

Usefull only for DL, as it links the columns of the matrix and the ideals.
It is created by replay. Each line is of the following form:
i h
where i is a column number of the matrix produced by replay (see XXX.small)
and h is the index of the ideal corresponding to the column.

i is written in decimal, h in hexadecimal

File XXX.index
==============

Is is created by replay, and contains the link between the rows of the
small matrix (coming out from merge/replay) and the relation sets to
which they correspond.

The first line gives number of rows (relation-sets) and columns (ideals)
after the merge/replay.

Then, each line of the file corresponds to a line of the small matrix:
the first entry is an integer giving the number of relations in the
relation-set, and the rest of the line gives the indices of the relations
(in hexadecimal). These indices relate to the numbers of the lines in the
purged.gz file.

For DL, each entry is of the form id:e, where id is the index in the
purged.gz file, and e is the exponent of the corresponding relation in
the relation-set.

File XXX.small.*.{txt|bin}
==========================

This is the set of files that describe the "small" matrix that is passed
to the linalg machinery. They are created by replay.

They exist in 2 different formats: txt or bin, the later is more compact.
We describe only the "txt" format, which is human-readable.

The matrix main file is XXX.small.txt. Its first line contains the number
of rows and columns. Then each line gives a row in the following format.
The first integer is the number of non-zero entries for this row. Then
the list of entries is given. In the case of factorization, an entry is
just a column index, and for DL, it is accompanied with its positive or
negative value.

The files XXX.small.rw.txt and XXX.small.cw.txt contains the row and
column weights.

If the parameter "skip" is non-zero, then the matrix is separated in a
dense and a sparse parts, so that additionnally to the previously
mentionned files, there are also "dense" versions.
