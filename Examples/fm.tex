\documentclass{article}

\usepackage{amstext}

\begin{document}
\title{What I understand from the code and what I aldready did}
\author{F. Morain}
\date{2007/11/30}

\maketitle

%%%%% S
\section{Example files}

I rebuilt the \verb+c59+ case, managed to have \verb+c80+ working and
I built a new \verb+c20+ for ease and speed of debug. I put everything
in the directory \verb+Examples/+. To see the current version of the
final programs in action, type
\begin{verbatim}
cd Examples/c20
../doit.sh c20
\end{verbatim}
To add more examples, you just need a \verb+name.poly+ file together
with the \verb+name.rels+ file.

\bigskip
{\bf Short glossary of matrices used:}

\begin{center}
\begin{tabular}{|c||c|c|c|c|}\hline
Matrix & $M_{rels}$ & $M_{purged}$ & $M_{small}$ & $M_{tiny}$ \\ \hline
Output by & {\tt sieve} & {\tt purge} & {\tt merge} & {\tt characters}
\\ \hline
\end{tabular}
\end{center}

The linear algebra crunching program operates on $M_{small}$.

%%%%% S
\section{The poly format}

\begin{verbatim}
n: 71641520761751435455133616475667090434063332228247871795429
skew: 355.125
# logmu: 64.40, alpha: -2.74 logmu+alpha=61.66
c3: 517165560
c2: 285105030
c1: -6927763164081
c0: -403598071832395153
# -403598071832395153*x^0-6927763164081*x^1+285105030*x^2+517165560*x^3;
Y1: 1
Y0: -51742221023983618
# m: 51742221023983618
type: gnfs
rlim: 200000               // rational prime bound
alim: 200000               // algebraic norm prime bound
lpbr: 23                   // log size bound on large prime (rational side)
lpba: 23                   // log size bound on large prime (alebraic side)
mfbr: 35
mfba: 35
rlambda: 1.2               // rational expansion factor
alambda: 1.2               // algebraic expansion factor
qintsize: 5000
# generated by polyselect rev. 259M -full -e 1000000 in 2s
\end{verbatim}

%%%%% S
\section{Workflow}

The program \verb+sieve+ outputs relations, consisting of pairs $(a,
b)$, together with the smallest primes dividing the rational
(resp. algebraic) side; in case the cofactor of the side is a prime,
add it to the list.

The program \verb+checknorms+ check the relations and norms, plus do
some extra factorization, {\bf in the case where the cofactor was not
already factored in the {\tt sieve} program}.

At the end of this process, we have a list of relations with complete
factorizations of $(a, b)$ pairs. A typical line in rough relation
file \verb+name.rels+ is
\begin{verbatim}
-1000,1:2,2,2,2,2,3,3,5,36d:d,c1,fb,d825
\end{verbatim}

%%%%% S
\section{Purging}

The program \verb+purge+ remove singletons, using as low central
memory as possible. The output file \verb+name.purged+ is
something like
\begin{verbatim}
nrows ncols
indab k i_1 i_2 ... i_k
\end{verbatim}
where the $i_u$'s are integers coding the remaining primes
associated to the relation $(a, b)$ tagged by index \verb+indab+,
which is (for the time being), the line number of file
\verb+name.rels+ corresponding to $(a, b)$. Using hashing for the
large primes, we manage to get the $i_u$'s in $[0..ncols[$. An
important trick for later use is that the \verb+indab+ are in
increasing order of index, so that a single scan of \verb+name.rels+
in correspondance of \verb+name.purged+ can recover the future $(a,
b)$ needed. 

The resulting matrix I call $M_{purged}$. All merge operations will
refer to this matrix, and later on it will be used to come back to
true relations. Note that we are only dealing with integers, not
distinguishing between rational, algebraic, small or large primes.

%%%%%%%%%% SS
\subsection{Hashing}

Copied from Cavallar's. Used in \verb+purge+ as well as later on for
rebuilding the rational square.

%%%%% S
\section{filtering}

Program \verb+merge+
will produce a file \verb+name.merge.his+ containing the history of
the different additions of rows, numbered sequentially from the file
\verb+name.purged+. Its structure is:
\begin{verbatim}
nrows ncols
r1 r2 ... rk
...
\end{verbatim}
\verb+nrows+ and \verb+ncols+ are the same as in file \verb+name.purged+;
a line \verb+r1 r2 ... rk+ means row \verb+r1+ was added into rows
\verb+r2+, \ldots, \verb+rk+ and \verb+r1+ subsequently destroyed.

Program \verb+replay+ produces the sparse encoding of the final {\em
small} matrix, under \verb+name.small+. It will also produce a file
\verb+name.index+ which for each row \verb+r+ in \verb+name.small+,
gives the list of the corresponding rows in \verb+name.purged+.

%%%%%%%%%% SS
\subsection{Useful parameters}

\begin{verbatim}
./merge ... -wmax w -maxlevel m
\end{verbatim}
\verb+w+ is a bound on the weight of the columns we play
with (default value 20). Filtering will be done on the {\em light}
part of $M_{purged}$, that is columns whose weight is $\leq
w$. Program \verb+replay+ will rebuild the true small sparse matrix.

Parameter \verb+m+ indicates the maximal level of merges to be
performed. The program begins with $m=2$ and then increases $m$. No
fancy termination is programmed yet, since more tuning with the linear
algebra must take place.

It is possible to have a merge of level $2$ and $3$ for the time
being, as a proof of concept of what follows.

%%%%%%%%%% SS
\subsection{Compact lists}

To spare memory, a list storing indices in {\em increasing order} like
\begin{verbatim}
i1 -> i2 -> ... -> ik
\end{verbatim}
is built as an array \verb+L+ s.t.
\begin{verbatim}
L[0] = k
L[1] = i1
...
L[k] = ik
\end{verbatim}
Operations to be performed are clever merges simulating mod 2
operations.

%%%%%%%%%% SS
\subsection{Example}

Let's consider the file \verb+fake.purged+:
\begin{verbatim}
15 10
100 3 9 2 3
101 4 5 6 7 8
102 2 1 2
103 3 5 7 4
104 5 1 4 6 7 8
105 2 8 4
106 3 9 8 0
107 2 6 1
108 3 0 9 5
109 1 7
110 2 8 9
111 3 6 1 2
112 4 4 6 7 9
113 6 1 8 3 4 5 9
114 2 4 5
\end{verbatim}
The first index in a row is needed to come back to the \verb+fake.rels+
file. The second index is the number of indices coming next.

The file corresponds to the matrix in dense form:
$$
\begin{array}{l|l|cccccccccc}
& & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\\hline
R_{0} & 100 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1\\
R_{1} & 101 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0\\
R_{2} & 102 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
R_{3} & 103 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 0\\
R_{4} & 104 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 1 & 0\\
R_{5} & 105 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0\\
R_{6} & 106 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\
R_{7} & 107 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
R_{8} & 108 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1\\
R_{9} & 109 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
R_{10} & 110 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\
R_{11} & 111 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
R_{12} & 112 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 1\\
R_{13} & 113 & 0 & 1 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1\\
R_{14} & 114 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\ \hline
\text{weight} & & 2 & 5 & 3 & 2 & 6 & 5 & 5 & 5 & 6 & 6 \\
\end{array}
$$
Since we do not need the indices referring to the rels matrix, we drop
them and only use the row indices of $M_{purged}$.

The index 0 has weight 2, so we perform $R_6 += R_8$ and $R_8$ is
destroyed:
$$
\begin{array}{l|cccccccccc}
R_{0}& x& 0& 1& 1& 0& 0& 0& 0& 0& 1\\
R_{1}& x& 0& 0& 0& 0& 1& 1& 1& 1& 0\\
R_{2}& x& 1& 1& 0& 0& 0& 0& 0& 0& 0\\
R_{3}& x& 0& 0& 0& 1& 1& 0& 1& 0& 0\\
R_{4}& x& 1& 0& 0& 1& 0& 1& 1& 1& 0\\
R_{5}& x& 0& 0& 0& 1& 0& 0& 0& 1& 0\\
\rightarrow R_{6}& 0& 0& 0& 0& 0& 1& 0& 0& 1& 0\\
R_{7}& x& 1& 0& 0& 0& 0& 1& 0& 0& 0\\
R_{8}& \multicolumn{10}{c}{NULL} \\
R_{9}& x& 0& 0& 0& 0& 0& 0& 1& 0& 0\\
R_{10}& x& 0& 0& 0& 0& 0& 0& 0& 1& 1\\
R_{11}& x& 1& 1& 0& 0& 0& 1& 0& 0& 0\\
R_{12}& x& 0& 0& 0& 1& 0& 1& 1& 0& 1\\
R_{13}& x& 1& 0& 1& 1& 1& 0& 0& 1& 1\\
R_{14}& x& 0& 0& 0& 1& 1& 0& 0& 0& 0\\
\hline
\text{weight}& 0& 5& 3& 2& 6& 5& 5& 5& 6& 4\\
\end{array}
$$
and the program outputs
\begin{verbatim}
8 6
\end{verbatim}

Now $j=3$ has also weight 2, yielding:
$$
\begin{array}{l|cccccccccc}
\rightarrow R_{0}& x& 1& 1& x& 1& 1& 0& 0& 1& 0\\
R_{1}& x& 0& 0& x& 0& 1& 1& 1& 1& 0\\
R_{2}& x& 1& 1& x& 0& 0& 0& 0& 0& 0\\
R_{3}& x& 0& 0& x& 1& 1& 0& 1& 0& 0\\
R_{4}& x& 1& 0& x& 1& 0& 1& 1& 1& 0\\
R_{5}& x& 0& 0& x& 1& 0& 0& 0& 1& 0\\
R_{6}& x& 0& 0& x& 0& 1& 0& 0& 1& 0\\
R_{7}& x& 1& 0& x& 0& 0& 1& 0& 0& 0\\
R_{8}& \multicolumn{10}{c}{NULL} \\
R_{9}& x& 0& 0& x& 0& 0& 0& 1& 0& 0\\
R_{10}& x& 0& 0& x& 0& 0& 0& 0& 1& 1\\
R_{11}& x& 1& 1& x& 0& 0& 1& 0& 0& 0\\
R_{12}& x& 0& 0& x& 1& 0& 1& 1& 0& 1\\
R_{13}& \multicolumn{10}{c}{NULL} \\
R_{14}& x& 0& 0& x& 1& 1& 0& 0& 0& 0\\
\hline
\text{weight}& x& 5& 3& x& 6& 5& 5& 5& 6& 2\\
\end{array}
$$
and the program outputs:
\begin{verbatim}
13 0
\end{verbatim}
Now, 9 has new weight 2, so that we can eliminate it:
$$
\begin{array}{l|cccccccccc}
R_{0}& x& 1& 1& x& 1& 1& 0& 0& 1& x\\
R_{1}& x& 0& 0& x& 0& 1& 1& 1& 1& x\\
R_{2}& x& 1& 1& x& 0& 0& 0& 0& 0& x\\
R_{3}& x& 0& 0& x& 1& 1& 0& 1& 0& x\\
R_{4}& x& 1& 0& x& 1& 0& 1& 1& 1& x\\
R_{5}& x& 0& 0& x& 1& 0& 0& 0& 1& x\\
R_{6}& x& 0& 0& x& 0& 1& 0& 0& 1& x\\
R_{7}& x& 1& 0& x& 0& 0& 1& 0& 0& x\\
R_{8}& \multicolumn{10}{c}{NULL} \\
R_{9}& x& 0& 0& x& 0& 0& 0& 1& 0& x\\
\rightarrow R_{10}& 0& 0& x& 0& 1& 0& 1& 1& 1& x\\
R_{11}& x& 1& 1& x& 0& 0& 1& 0& 0& x\\
R_{12}& \multicolumn{10}{c}{NULL} \\
R_{13}& \multicolumn{10}{c}{NULL} \\
R_{14}& x& 0& 0& x& 1& 1& 0& 0& 0& x\\
\hline
\text{weight}& x& 5& 3& x& 6& 5& 5& 5& 6& x\\
\end{array}
$$
We see that index 2 has weight 3. The optimal pairing of rows is to
perform $R_0 += R_2$, $R_{11} += R_2$ to get:
$$
\begin{array}{l|cccccccccc}
R_{0}& x& 0& x& x& 1& 1& 0& 0& 1& x\\
R_{1}& x& 0& x& x& 0& 1& 1& 1& 1& x\\
R_{2}& \multicolumn{10}{c}{NULL} \\
R_{3}& x& 0& x& x& 1& 1& 0& 1& 0& x\\
R_{4}& x& 1& x& x& 1& 0& 1& 1& 1& x\\
R_{5}& x& 0& x& x& 1& 0& 0& 0& 1& x\\
R_{6}& x& 0& x& x& 0& 1& 0& 0& 1& x\\
R_{7}& x& 1& x& x& 0& 0& 1& 0& 0& x\\
R_{8}& \multicolumn{10}{c}{NULL} \\
R_{9}& x& 0& x& x& 0& 0& 0& 1& 0& x\\
R_{10}& x& 0& x& x& 1& 0& 1& 1& 1& x\\
R_{11}& x& 0& x& x& 0& 0& 1& 0& 0& x\\
R_{12}& \multicolumn{10}{c}{NULL} \\
R_{13}& \multicolumn{10}{c}{NULL} \\
R_{14}& x& 0& x& x& 1& 1& 0& 0& 0& x\\
\hline
\text{weight}& x& 2& x& x& 6& 5& 5& 5& 6& x\\
\end{array}
$$
We stop here, though we go along this new weight 2 column.

The \verb+fake.merge.his+ file contains
\begin{verbatim}
15 10
8 6
13 0
12 10
2 0 11
\end{verbatim}

Now, we start \verb+replay+ which builds the \verb+fake.index+ file:
\begin{verbatim}
12 7
2 0 13
1 1
1 2
1 3
1 4
1 5
2 6 8
1 7
1 9
2 10 12
1 11
1 14
\end{verbatim}
This means that row 0 of $M_{small}$ is the sum of row 0 and 13 of
$M_{purged}$; row 1 is row 1, etc.

The file \verb+fake.small+ contains $M_{small}$ is sparse form:
\begin{verbatim}
12 7
5 1 0 5 2 6
4 2 3 4 6
2 1 0
3 5 2 4
5 1 5 3 4 6
2 5 6
2 2 6
2 1 3
1 4
4 5 3 4 6
3 1 0 3
2 5 2
\end{verbatim}
We find 5 dependence relations:
\begin{verbatim}
d8        -> 1101|1000
168
262
42e
860
\end{verbatim}
As a check, the relation
$$R_3'+R_4'+R_6'+R_7'$$
should be zero and it is. To check even further, we look at the
original matrix, replacing the $R'$ by the corresponding $R$:
$$(R_3)+(R_4)+(R_6+R_8)+(R_7)$$
should also be zero.

%%%%% S
\section{Characters and squareroots}

We need to recover the $(a, b)$ needed, by using all the indirections
caused by the preceding files. A fast recovery is possible, since we
preserved order everyone. The same thing will be used for
reconstructing the rational and algebraic squares, using programs
\verb+allsqrt+ and later on \verb+fmalgsqrt.c+. Some optimization will
be needed here and there, but for now it is enough. 

Dependancies are produced as \verb+name.dep.rat.000+ and
\verb+name.dep.alg.000+, so that we can work on different squareroots
at the same time if needed.

%%%%% S
\section{Finish in magma}

Some cleaning was done, enabling now to use the same program on
different data.

\iffalse
%%%%% S
\section{Deprecated stuff}

%%%%%%%%%% SS
\subsection{procrels}

That is a very naive program whose aim is to get rid of singletons,
being either $5$ or a large prime (convenient, after all?).

It is naive in the way it is programmed: first build a big table of
all primes occurring in relations, then sort it, then crunch it to get
rid of duplicates!!!! No hashing is performed.

This program cannot be used as the basis of the filtering step, so
that everything has to be written from scratch!

All the relations are to fit in core memory!!

Programming leads to potentially very slow computations, since many
operations are done slowly.
\fi

\end{document}
