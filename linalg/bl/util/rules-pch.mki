
# These rules may be used to enable precompiled headers, but that does
# not win so much.
#
# Note : gcc -H can be used to track whether the right .gch's are used.
#
ifneq ($(shell g++ -v 2>&1 | grep 3.4),)
CXXFLAGS+=-Winvalid-pch
endif

%.hpp.gch: %.hpp
	$(CXX) -x c++-header -c $(CXXFLAGS) $< -o /tmp/"`basename $@`"
	ln -sf /tmp/"`basename $@`" $@

# Note ; this rule features two hacks.
#
# First, we include the deps file in the targets. Obviously, if one of
# the source file changes, this possibly invalidates the .d file.
# 
# Second, we add some stuff related to the precompiled headers. Any
# _pch.hpp file is treated as a collection of common headers (presumably,
# it's actually $*_pch.hpp, but it's not currently enforced). Instead of
# depending on such a header, me make the build system depend on the .gch
# file instead. Note that any include file actually referenced by the
# _pch.hpp file will invalidate the target. It's correct, but in fact it
# is would be sufficient to invalidate the .gch file, which is done
# anyway. Obviously this second trick does _NOT_ impact on the .d target.
#
# We're calling cpp twice ; it allows for a simpler makefile rule,
# although it does have a minor cost.

%.d:	%.cpp
	@echo "Doing depcheck on $<"
	@rm -f $@
	@$(CXX) $(CXXFLAGS) -M -MM $< -MT $@ >> $@
	@$(CXX) $(CXXFLAGS) -M -MM $< | sed -e 's/_pch\.hpp\>/&.gch/g' >> $@
	@[ -s $@ ] || rm -f $@
%_pch.d:	%_pch.hpp
	@echo "Doing depcheck on $<"
	@rm -f $@
	@$(CXX) $(CXXFLAGS) -x c++-header -M -MM $< -MT $@ >> $@
	@$(CXX) $(CXXFLAGS) -x c++-header -M -MM $< -MT $<.gch >> $@
	@[ -s $@ ] || rm -f $@

# vim:ft=make
