--- /tmp/master_binary.cpp	2007-11-28 00:37:03.000000000 +0100
+++ cxx/master_binary.cpp	2007-11-28 00:38:07.000000000 +0100
@@ -154,18 +154,18 @@
     uint ncols;
     private:
     boost::shared_array<ulong> x;
-    std::vector<uint> order;
+    boost::shared_array<uint> order;
     inline uint stride() const { return BITS_TO_WORDS(nrows, ULONG_BITS); }
     public:
     bmat(uint nrows, uint ncols)
         : nrows(nrows), ncols(ncols), x(new ulong[ncols*stride()]),
-        order(ncols)
+        order(new uint[ncols])
     {
         memset(x.get(), 0, ncols*stride()*sizeof(ulong));
         for(uint j = 0 ; j < ncols ; j++) order[j]=j;
     }
     bmat() : nrows(0), ncols(0) {}
-    void clear() { nrows = ncols = 0; x.reset(); order.clear(); }
+    void clear() { nrows = ncols = 0; x.reset(); order.reset(); }
     bmat(bmat const& a) : nrows(a.nrows), ncols(a.ncols), x(a.x), order(a.order) {}
     bmat& operator=(bmat const& a) {
         nrows = a.nrows;
@@ -177,7 +177,7 @@
     bmat clone() const {
         bmat dst(nrows, ncols);
         memcpy(dst.x.get(), x.get(), ncols*stride()*sizeof(ulong));
-        dst.order = order;
+        memcpy(dst.order.get(), order.get(), ncols*sizeof(uint));
         return dst;
     }
     /* zero column j */
@@ -249,7 +249,11 @@
      * now be accessed at index p[i]
      */
     void perm(uint * p) {
-        permute(order, p);
+        boost::shared_array<uint> norder(new uint[ncols]);
+        for(uint i = 0 ; i < ncols ; i++) {
+            norder[p[i]]=order[i];
+        }
+        order.swap(norder);
     }
     void addcoeff(uint i, uint j, ulong z)
     {
@@ -277,8 +281,8 @@
     static bool critical;
     private:
     boost::shared_array<ulong> x;
-    std::vector<uint> order;
-    std::vector<int> _deg;
+    boost::shared_array<uint> order;
+    boost::shared_array<int> _deg;
     inline uint stride() const { return BITS_TO_WORDS(ncoef, ULONG_BITS); }
     inline uint colstride() const { return nrows * stride(); }
     static void brev_warning();
@@ -288,8 +292,8 @@
     polmat(uint nrows, uint ncols, uint ncoef)
         : nrows(nrows), ncols(ncols), ncoef(ncoef),
         x(new ulong[ncols*colstride()]),
-        order(ncols),
-        _deg(ncols)
+        order(new uint[ncols]),
+        _deg(new int[ncols])
     {
         memset(x.get(), 0, ncols*colstride()*sizeof(ulong));
         for(uint j = 0 ; j < ncols ; j++) order[j]=j;
@@ -298,8 +302,8 @@
     void clear() {
         nrows = ncols = ncoef = 0;
         x.reset();
-        order.clear();
-        _deg.clear();
+        order.reset();
+        _deg.reset();
     }
     polmat() : nrows(0), ncols(0), ncoef(0) {}
     polmat(polmat const& a) :
@@ -307,8 +311,8 @@
         ncols(a.ncols),
         ncoef(a.ncoef),
         x(a.x),
-        order = a.order;
-        _deg = a._deg;
+        order(a.order),
+        _deg(a._deg)
     {
         /* There's a catch here. Perhaps we should do copy on write on
          * the non-const methods ??? This could be done easily by calling
@@ -341,8 +345,8 @@
     polmat clone() {
         polmat dst(nrows, ncols, ncoef);
         memcpy(dst.x.get(), x.get(), ncols*colstride()*sizeof(ulong));
-        order = a.order;
-        _deg = a._deg;
+        memcpy(dst.order.get(), order.get(), ncols*sizeof(uint));
+        memcpy(dst._deg.get(), _deg.get(), ncols*sizeof(uint));
         return dst;
     }
     /* this handles expansion and shrinking */
