/*
Wrapper version, to be used with
  magma -b polyfile:=$POLY renumber:=$RENUMBER algpr:=$ALGPR generators:=$GENERATORS badideals:=BADIDEALS purged:=$PURGED index:=$INDEX ficunits:=$FICUNITS ww:=true/false $DIR/nfsunits.mag
*/

//
// author: morain@lix.polytechnique.fr 
//
// Using units in SNFS-DL

NFSUNITS_VERSION:="20140313.2000";

printf "## NFSUNITS_VERSION %o\n", NFSUNITS_VERSION;
SetDebugOnError(true);

QQ:=Rationals();
QX<X>:=PolynomialRing(QQ);
QXT<T>:=PolynomialRing(QX);

DLP_USE_UNITS_FLOAT:=true;
R20:=RealField(20);
C20:=ComplexField(R20);
RR:=RealField(50);
RRY<Y>:=PolynomialRing(RR);
CC:=ComplexField(RR);
CCZ<Z>:=PolynomialRing(CC);

DLP_DEBUG:=1;
DLP_VERIFICATION:=false; // for expert debug mode only...

// precompute all products of units^ex with |ex| <= bound.
BuildGroupTable := function(UK, bound)
        if DLP_DEBUG ge 2 then
	    printf "# BSGT --> %o at %o\n", UK, Cputime();
	end if;
	G:=AssociativeArray();
	if #UK eq 1 then
	    for i:=-bound to bound do
	        G[UK[1]^i]:=[i];
	    end for;
	else
	    GG:=$$(UK[1..#UK-1], bound);
	    for i:=-bound to bound do
	        prod:=UK[#UK]^i;
		for pr in Keys(GG) do
		    G[prod * pr]:=GG[pr] cat [i];
		end for;
	    end for;
	end if;
	if DLP_DEBUG ge 2 then
 	    printf "# <-- BSGT %o at %o\n", UK, Cputime();
	end if;
	return G;
end function;

// x in K, so a poly in t -> real poly.
AlgToReal := function(x)
        return RRY ! [ RR ! y : y in Eltseq(x)];
end function;

// x in K, so a poly in t -> real poly.
AlgToComplex := function(x)
        return CCZ ! [ CC ! y : y in Eltseq(x)];
end function;

// For elt in K.
AllEmbeddings := function(U, x)
	K:=Parent(x);
	if U["rK"] eq Degree(K)-1 then
    	    rx:=AlgToReal(x);
	    return [Log(Abs(Evaluate(rx, R20!z))) : z in U["roots"]];
	elif 2*U["rK"]+2 eq Degree(K) then
    	    rx:=AlgToComplex(x);
	    return [Log(Abs(Evaluate(rx, z))) : z in U["roots"]];
	else
	    error("Pb in AllEmbeddings");
	end if;
end function;

FiPoBounds := function(B, K, logunits)
        U:=[];
	for i:=1 to Degree(K) do
	    U[i]:=&+ [Abs(logunits[j][i]) : j in [1..#logunits]];
	    U[i]:=Exp((Log(B)/Degree(K)) + 0.5 * U[i]);
	end for;
	return U;
end function;

// rK = 1
Minimize1 := function(x, lx, U)
	units:=U["units"];
	lunits:=U["logunits"];
	a1min:=&+ [ lx[i] * lunits[1][i] : i in [1..#lx] ];
	a1min:=a1min / (&+ [ lunits[1][i]^2 : i in [1..#lx] ])^2;
//	printf "a1min = %o\n", a1min;
	a1min:=Round(a1min);
        return x/units[1]^a1min;
end function;

// rK = 2
Minimize2 := function(x, lx, U)
	units:=U["units"];
	lunits:=U["logunits"];
	min:=10^30;
	for a1:=-3 to 3 do
	    tmp1:=[lx[i]-a1*lunits[1][i] : i in [1..#lx]];
	    for a2:=-3 to 3 do
	        tmp:=&+ [(tmp1[i]-a2*lunits[2][i])^2 : i in [1..#lx]];
		if tmp le min then
//		    printf "a1=%o a2=%o tmp=%o\n", a1, a2, tmp;
		    min:=tmp;
		    a1min:=a1; a2min:=a2;
		end if;
	    end for;
	end for;
	u:=units[1]^a1min*units[2]^a2min;
        return x/u;
end function;

// rK = 3
Minimize3 := function(x, lx, U)
        units:=U["units"];
        lunits:=U["logunits"];
	min:=10^30;
	for a1:=-3 to 3 do
	  for a2:=-3 to 3 do
	    for a3:=-3 to 3 do
	        tmp:=&+ [(lx[i]-a1*lunits[1][i]-a2*lunits[2][i]-a3*lunits[3][i])^2 : i in [1..#lx]];
		if tmp le min then
//		    printf "a1=%o a2=%o tmp=%o\n", a1, a2, tmp;
		    min:=tmp;
		    a1min:=a1; a2min:=a2; a3min:=a3;
		end if;
	    end for;
	  end for;
	end for;
	u:=units[1]^a1min*units[2]^a2min*units[3]^a3min;
        return x/u;
end function;

Minimize := function(K, U, x)
	lx:=AllEmbeddings(U, K!x);
	if U["rK"] eq 1 then return Minimize1(x,lx,U);
	elif U["rK"] eq 2 then return Minimize2(x,lx,U);
	elif U["rK"] eq 3 then return Minimize2(x,lx,U);
	else return x;
	end if;
end function;

InsertInBox := procedure(~l, K, U, elt, lipr, pmax)
	no:=Integers() ! Abs(Norm(elt));
	if IsDefined(lipr, no) then // meaning no is prime...!
//	    printf "elt=%o no=%o\n", elt, no;
	    if not IsDefined(l, no) then
	        l[no]:=[elt];
	    elif #l[no] lt Degree(K) then
	        // l[no] contains distinct prime ideals
		ok:=true;
		// if elt/x is never an integer we gain a new factor
		for i:=1 to #l[no] do
		    x:=l[no][i];
		    r:=elt/x;
		    if IsIntegral(r) then
		        ok:=false;
			break;
		    end if;
		end for;
		if ok then
	 	    l[no]:=Append(l[no], elt);
		end if;
//if #l[no] gt 2 then print l[no]; error("TTTT"); end if;
	    end if;
	end if;
end procedure;

// Perhaps a more carefully used ellipsoid would be better?
EPN3 := function(K, OK, U, lipr, bound, pmax)
        tp:=Cputime();
	l:=AssociativeArray();
	for a0:=0 to bound do
	    printf "# a0 = %o at %o\n", a0, Cputime();
	    for a1:=-bound to bound do
	        for a2:=-bound to bound do
		    elt:=a0*OK.1+a1*OK.2+a2*OK.3;
		    InsertInBox(~l, K, U, elt, lipr, pmax);
	    	end for;
	    end for;
	end for;
	printf "#T# EPN3: %o\n", Cputime(tp);
	return l;
end function;

EPN4 := function(K, OK, U, lipr, bound, pmax)
        tp:=Cputime();
	l:=AssociativeArray();
	for a0:=0 to bound do
	    printf "# a0 = %o at %o\n", a0, Cputime();
	    for a1:=-bound to bound do
	        for a2:=-bound to bound do
	 	    for a3:=-bound to bound do
		    	elt:=a0*OK.1+a1*OK.2+a2*OK.3+a3*OK.4;
			InsertInBox(~l, K, U, elt, lipr, pmax);
	 	    end for;
	    	end for;
	    end for;
	end for;
	printf "# time for EPN4: %o\n", Cputime(tp);
	return l;
end function;

// generate boxes: a^bound = pamax??
EnumeratePrimeNorms := function(K, OK, U, lipr, pmax)
	printf "# bounds = %o\n", FiPoBounds(pmax, K, U["logunits"]);
	bound:=125; // FIXME: do better!
        if Degree(K) eq 3 then l:=EPN3(K, OK, U, lipr, bound, pmax);
        elif Degree(K) eq 4 then l:=EPN4(K, OK, U, lipr, bound, pmax);
	end if;
	tp:=Cputime();
	for no in Keys(l) do
	    l[no]:=[Minimize(K, U, x) : x in l[no]];
	end for;
	printf "#T# minimizing generators: %o\n", Cputime(tp);
	return l; 
end function;

// u_1, ..., u_ell with ell = r1+r2-1; if r1 > 0, u0 = -1.
// We suppose f has real roots alpha_1, ..., alpha_{r_1}
// and complex roots alpha_{r_1+1}, ..., alpha_n
// s.t. alpha_{r_1+r_2+j} is the complex conjugate of alpha_{r_1+j}
// for 1 <= j <= r_2. Note that r1+2*r2 = n = deg(K) = deg(f).
// For 1 <= i <= ell, varphi_i(alpha) = alpha_i.
// U["units"] will contain units in OK as EltSeq.
PrepareUnits := procedure(~U, ~G, K, OK, genG)
	r1,r2:=Signature(K);
	rK:=r1+r2-1;
	printf "# r1=%o, r2=%o => rK=%o\n", r1, r2, rK;
	// boxes will have bound^{2*rK} points
	if rK le 2 then bound:=20;
	elif rK le 3 then bound:=10;
	else bound:=5; end if;
	f:=DefiningPolynomial(K);
	if r2 eq 0 then
	    lr:=[r[1] : r in Roots(AlgToReal(f))];
	elif r1 eq 0 then
	    lr0:=[r[1] : r in Roots(AlgToComplex(f))];
	    if DLP_DEBUG ge 3 then printf "lr0=%o\n", lr0; end if;
	    // assuming that roots are [alpha1, conj(alpha1), ...]
	    // reorder them to [alpha1, alpha2, ..., alpha_r2, conj(alpha1)...]
	    lr:=[];
	    for i:=1 to r2 do
	        lr[i]:=lr0[2*i-1];
		lr[i+r2]:=lr0[2*i];
	    end for;
	else
	    // TODO: order roots of f...!
	    error("NYI");
	end if;
	printf "# ordered roots: %o\n", lr;
	UK,map:=UnitGroup(K);
	printf "# UK = %o\n", UK;
	// if r1 > 0, u0 = -1 is a unit
	// we do not consider the sign (nor torsion elements)
	units:=[];
	for gen in Generators(UK) do
	    if Order(gen) ne 2 then
	        units[#units+1]:=OK!map(gen);
	    end if;
	end for;
//	printf "# units_OK = %o\n", units;
	printf "# units_K = %o\n", [K!u : u in units];
	// build matrix
	M:=KMatrixSpace(RR, rK, rK)!0;
	for i:=1 to rK do
	    // fill in the i-th column
	    fui:=AlgToReal(K!units[i]);
	    printf "i=%o => %o\n", i, fui;
	    for j:=1 to rK do
	        M[j, i]:=Log(Abs(Evaluate(fui, lr[j])));
	    end for;
	end for;
	print M;
	if genG then
	    printf "# BuildGroupTable with bound %o\n", bound;
	    tp:=Cputime();
	    G:=BuildGroupTable(units, bound);
	    printf "#T# BGT: %o\n", Cputime(tp);
	end if;
	U["roots"]:=lr;
	U["units"]:=units;
	U["rK"]:=rK;
	U["Minv"]:=M^(-1);
	U["logunits"]:=[AllEmbeddings(U, K!units[i]) : i in [1..rK]];
end procedure;

// If x is not close enough to an integer, do not round it!
Roundify := function(x)
	prec:=Precision(x);
	ix:=Round(x);
	if Abs(ix-x) gt 10^(-0.5 * prec) then error("Precision pb?"); end if;
	return ix;
end function;

// INPUT: Keys(U) = {"grouptable", "roots", "units", "rK"}
//        eta is in OK.
RecoverUnits := function(U, K, eta)
	G:=U["grouptable"];
	if IsDefined(G, eta) then
	    return [1] cat G[eta];
	elif IsDefined(G, -eta) then
	    return [-1] cat G[-eta];
	end if;
//if not DLP_USE_UNITS_FLOAT or eta eq 1 or eta eq -1 then return eps; end if;
//	if DLP_DEBUG ge 2 then printf "Found eps = %o\n", eps; end if;
	rK:=U["rK"];
	lr:=U["roots"];
	// don't forget to send eta in K...
	V:=[Log(Abs(Evaluate(AlgToReal(K!eta), lr[i]))) : i in [1..rK]];
	if DLP_DEBUG ge 2 then
	    printf "V = %o\n", V;
	end if;
	eps:=[];
	// compute Minv * V
	for i:=1 to rK do
	    tmp:=&+ [ U["Minv"][i, j] * V[j] : j in [1..rK] ];
	    eps[i]:=Roundify(tmp);
	    if DLP_DEBUG ge 2 then
	        printf "%o -> %o = %o\n", i, tmp, eps[i];
	    end if;
	end for;
	chk:=&* [U["units"][i]^eps[i] : i in [1..rK]];
	if eta ne chk and eta ne -chk then
	    printf "PB: %o %o\n", eta, chk;
	    error("Check");
	end if;
        printf "# floating point recovery for %o: %o\n", eta, eps;
//error("DD");
	// do a stupid sign-like normalization
	return [1] cat eps;
end function;

// lr contains the roots of f(X) mod p without multiplicity.
// WARNING: does work for easy examples only...!
// OUTPUT: [[c1, p1, e1], ..., [ck, pk, ek]], 
// e_i = ramification index, f_i = residual degree.
GetIdeals := function(K, OK, p, lr)
	lgp:=[];
	eta:=p;
	if #lr eq 1 then
	    // resort to Magma
	    r:=lr[1];
	    lf:=Factorization(p * OK);
	    printf "(%o) = %o\n", p, lf;
	    for id in lf do
	        ok,gp:=IsPrincipal(id[1]);
	    	if not ok then error("Not principal"); end if;
		// check this?
		for i:=1 to id[2] do
		    eta:=eta / gp;
		end for;
		lgp[#lgp+1]:=<r, gp, id[2]>;
	    end for;
	elif #lr eq Degree(K) then
	    tmp:=[0 : i in [1..Degree(K)-2]];
	    for r in lr do
	    	id:=ideal<OK | [p, 0] cat tmp, [p-r, 1] cat tmp>;
//	    	printf "id=%o, Norm=%o\n", id, Norm(id);
	    	ok,gp:=IsPrincipal(id);
//		printf "gen(id)=%o\n", gp;
	    	if not ok then error("Not principal"); end if;
	    	lgp[#lgp+1]:=<r, gp, 1>;
	    	eta:=eta / gp;
	    end for;
	else
	    error("#lr not permitted yet");
	end if;
	if DLP_DEBUG ge 2 then printf "lgp = %o\n", lgp; end if;
	if #lgp eq Degree(K) then
	    // a free relation
	    if DLP_DEBUG ge 2 then
	        printf "free relation: p = %o, eta = %o of norm %o\n", 
	    	   p, OK!eta, Norm(eta);
	    end if;
	end if;
	if Abs(Norm(eta)) ne 1 then error("Not a unit"); end if;
	return <lgp, OK!eta>;
end function;

// We should have f(c) = 0 mod p
UpdateFB := procedure(~FB, K, OK, U, p, c)
	f:=DefiningPolynomial(K);
        if DLP_DEBUG ge 2 then
	    printf "# computing roots of f mod %o\n", p;
	end if;
	FpX<X>:=PolynomialRing(GF(p));
	fp:=FpX!Eltseq(f);
	if Evaluate(fp, c) ne 0 then error("not a root"); end if;
if false then // false for ramified primes!!!!!
		    fp:=fp div (X-c);
		    lr:=Roots(fp);
		    lr:=[c] cat [Integers()!r[1] : r in lr];
else
	lr:=Roots(fp);
	lr:=[Integers()!r[1] : r in lr];
end if;
	FBp:=GetIdeals(K, OK, p, lr);
	if FBp[2] ne 0 then
	    // free relation: recover eps...!
	    eps:=RecoverUnits(U, K, FBp[2]);
	    if eps eq [] then error("No unit found"); end if;
	    FBp:=<FBp[1], eps>;
	end if;
	FB[p]:=FBp;
	if DLP_DEBUG ge 2 then printf "FB[%o]=%o\n", p, FB[p]; end if;
end procedure;

// p^ex || norm.
// INPUT: FB[p] = <[<c1, gen1, e1>, ..., <ck, genk, ek>], eps_p>
// 	  where id1 = [p, p-c1], ...
//	  eta should be in OK
// Remember that (p) = p*OK = prod_{i=1}^g P_i^e_i, where Norm(P_i) = p^f_i
// and sum_i e_i f_i = n = degree(K).
// If K is abelian (e.g., cyclic), e_i = e, f_i = f and e*f*g = n.
// An inert prime is (1, n, 1).
// For non inert primes:
// n prime: (e, f, g) = (1, 1, n) or (n, 1, 1);
// n = 4: (1, 1, 4) or (2, 2, 1) or (2, 1, 2) or (1, 2, 2).
DivideGivenNorm := procedure(~eta, K, OK, FB, p, ex, c)
        n:=Degree(K);
	g:=#FB[p][1];
	// abelian case only, easy to change
	e:=FB[p][1][1][3]; // ramification index
	f:=n div (g*e);    // residual degree
	ok:=false;
	for ee:=1 to (ex div f) do
	    for id in FB[p][1] do
	    	if id[1] eq c then
	            tmp:=eta/OK!id[2];
// print id[2], tmp, Norm(tmp);
		    // this will solve the multiple roots pb
		    if IsIntegral(tmp) then
		        eta:=tmp;
		        ok:=true;
		    end if;
	    	end if;
	    end for;
	end for;
	if not ok then error("No ideal found"); end if;
end procedure;

// lf = factorization of Norm(a-b*t) = [<p1, ex1>, ...]
Treat_a_b := procedure(~FB, ~eps, K, OK, U, a, b, lf)
	t:=K.1;
	f:=DefiningPolynomial(K);
	if DLP_DEBUG ge 2 then printf "a=%o, b=%o: %o\n", a, b, lf; end if;
	theta:=(a-b*t);
	eta:=OK!theta;
	for pe in lf do // code_123
	    p,ex:=Explode(pe);
	    if b mod p eq 0 then
	        error("b = 0 mod p: NYI", b);
	    else
		c:=(a * Modinv(b, p)) mod p;
		if not IsDefined(FB, p) then
		    UpdateFB(~FB, K, OK, U, p, c);
		end if;
		DivideGivenNorm(~eta, K, OK, FB, p, ex, c);
	    end if;
	    if DLP_DEBUG ge 3 then
	        printf "new theta=%o\n", eta;
	    end if;
	end for;
	eta:=OK!eta;
	if DLP_DEBUG ge 2 then
	    printf "eta=%o => Norm=%o\n", eta, Norm(eta);
	end if;
	eps:=RecoverUnits(U, K, eta);
	if eps eq [] then error("no unit found for ", eta); end if;
	if DLP_DEBUG ge 2 then
	    printf "eps=%o\n", eps;
	end if;
end procedure;

TreatFromFile := procedure(~FB, ~epsab, p, f, g, m, K, OK, U, fic)
	t:=K.1;
        fd:=POpen("gzip -dc " * fic, "r");
	nr:=0;
	while true do
	    s:=Gets(fd);
            if IsEof(s) then break; end if;
	    // skip comments
	    if s[1] eq "#" then continue; end if;
	    // s = "88723,10093:3,3,3,3,5,1d,1af,42d,1db7,4b13,beead:13,25,e9,5029,30d51"
	    tmp:=Split(s, ":");
	    ab:=Split(tmp[1], ",");
	    nr:=nr+1;
	    if nr mod 1000 eq 0 then
	        printf "# %o relations treated at %o\n", nr, Cputime();
	    end if;
//	    printf "R%o: %o\n", nr, ab;
	    a:=StringToInteger(ab[1]);
	    b:=StringToInteger(ab[2]);

	    // recover factorization from rational part
	    // which is "3,3,3,3,5,1d,1af,42d,1db7,4b13,beead" where numbers
	    // are actual primes
	    if DLP_VERIFICATION then
	        abm:=a-b*m;
//	    	lg:=Factorization(a-b*m);
//	    	printf "lg = %o // %o\n", lg, tmp[2];
	    	rat:=Split(tmp[2], ",");
	    	lg:=[];
	        for p in rat do
	            pp:=StringToInteger(p, 16);
		    if abm mod pp ne 0 then error(abm, pp); end if;
		    abm:=abm div pp;
		    lg[#lg+1]:=pp;
	    	end for;
//	    	printf "cof(abm)=%o\n", abm;
	    	if Abs(abm) ne 1 then error("|cof| != 1"); end if;
	    end if;

	    // algebraic part: "13,25,e9,5029,30d51" where numbers are actual
	    // primes dividing the norm of a-b*t
	    no:=Integers()!Norm(a-b*t);
	    alg:=Split(tmp[3], ",");
	    lf:=[];
if false then // code_123
	    for p in alg do
	        pp:=StringToInteger(p, 16);
		if no mod pp ne 0 then error(no, pp); end if;
		no:=no div pp;
		lf[#lf+1]:=pp;
	    end for;
else // not faster! but more convenient
	    ppold:=0;
	    for p in alg do
	        pp:=StringToInteger(p, 16);
		if pp ne ppold then
	  	    ex,no:=Valuation(no, pp);
		    if ex eq 0 then error(no, pp); end if;
		    lf[#lf+1]:=<pp, ex>;
		    ppold:=pp;
		end if;
	    end for;
end if;
//	    printf "cof(no)=%o\n", no;
	    if Abs(no) ne 1 then error("|cof| != 1"); end if;

	    Treat_a_b(~FB, ~eps, K, OK, U, a, b, lf);
	    epsab[[a, b]]:=eps;
//break;
	end while;
if false then
        // compute stats here...!
	stats:=AssociativeArray();
	if IsDefined(stats, eps) then
	    stats[eps]:=stats[eps]+1;
	else
	    stats[eps]:=1;
	end if;
	for k in Keys(stats) do
	    printf "%o %o\n", stats[k], k;
	end for;
end if;
end procedure;

// U = <G, rt, funits>
// OUTPUT: epsab[a, b] = unit if factorization of a-b*alpha
TreatFromDir := procedure(~FB, ~epsab, p, f, g, m, K, OK, U, dir)
	tmp:=dir * ".units.listfiles";
	cmd:="ls " * dir * ".sieving* > " * tmp;
        System(cmd);
	fd:=Open(tmp, "r");
	nf:=0;
	while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    nf:=nf+1;
	    printf "## Operating on file %o: %o\n", nf, s;
	    TreatFromFile(~FB, ~epsab, p, f, g, m, K, OK, U, s);
	end while;
end procedure;

// Useful for verifying.
ReadFactorBase := procedure(~FB, K, OK, U, fb, degf)
	printf "# Reading factor base\n";
	f:=DefiningPolynomial(K);
	t:=K.1;
        fd:=POpen("gzip -dc " * fb, "r");
	while true do
	    s:=Gets(fd);
            if IsEof(s) then break; end if;
	    if s[1] eq "#" then continue; end if;
	    tmp:=Split(s, ":");
	    if #tmp eq 3 then printf "powers? %o\n", tmp; continue; end if;
	    p:=StringToInteger(tmp[1]);
	    tmp:=Split(tmp[2], ",");
	    // "3: 2" special???
	    if #tmp lt Degree(f) then
	        printf "ramified? p=%o => %o\n", p, tmp;
	    end if;
	    // "17: 7,13,14" normal case
	    lr:=[StringToInteger(tmp[i]) : i in [1..#tmp]];
//	    printf "p = %o => lr = %o\n", p, lr;
	    // p*OK has factors [p, t-r]
//	    printf "p*OK = %o\n", Factorization(p*OK);
	    FBp:=GetIdeals(K, OK, p, lr);
	    if FBp[2] ne 0 then
	        eps:=RecoverUnits(U, K, FBp[2]);
          	if eps eq [] then error("No unit found"); end if;
                FBp:=<FBp[1], eps>;
	    end if;
	    FB[p]:=FBp;
	    if DLP_DEBUG ge 2 then
	        printf "FB[%o]=%o\n", p, FB[p];
	    end if;
//if p gt 50 then error("TBC"); end if;
	end while;	      
end procedure;

// From README.fileformat:
// File XXX.purged.gz
// ==================
// 
// It is created by purge, and contains a set of relations without
// singleton, and where all or almost all the excess has been used.
// 
// The first line has the following format:
// # nr lc nc
// where
//   - nr is the number of rows (relations)
//   - lc is the index of the last column (ideal) that has non-zero weight
//   - nc is the number of columns (ideals)
// nr, lc and nc are written in decimal.
// 
// Then, each line of the file corresponds to one relation: a,b:h_0,....h_k
// where
//   - a and b give the (a,b) pair of the original relation
//   - h_i is an index of an ideal appearing in the relation. For factorization, an
//     ideal appears at most one per relation. For DL, if an ideal more than
//     once in the relation, all these occurences are guaranteed to be one after
//     the other.
// a,b and the h_i's are in hexadecimal.
//
DLReadPurged := function(purged)
        ab:=[];
        fd:=POpen("gzip -dc " * purged, "r");
	s:=Gets(fd);
	// read first line: s = "# 10807 37271 10805"
	tmp:=Split(s, " ");
	nr:=StringToInteger(tmp[2]);
	lc:=StringToInteger(tmp[3]);
	nc:=StringToInteger(tmp[4]);
	printf "# nr = %o, lc = %o, nc = %o\n", nr, lc, nc;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "-ad21b,8217:4,6,6,c,18,166,1c9,5f4,ad3,1fbc,14,8e,7e7,e23,8d73,0"
	    tmp:=Split(s, ":");
	    tmp:=Split(tmp[1], ",");
	    a:=StringToInteger(tmp[1], 16);
	    b:=StringToInteger(tmp[2], 16);
	    ab[#ab+1]:=[a, b];
	end while;
	return ab;
end function;

ReadBadIdeals := function(K, badidealinfo)
	printf "# reading badidealinfo\n";
	fd:=Open(badidealinfo, "r");
	bad:=[];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    print s;
	    // s = "### 3 (2 : 1) 1 [ 1 ] (i=1: ramified, e=3) ; easy."
	    tmp:=Split(s, " ");
	    if "easy." in tmp then
		pp:=StringToInteger(tmp[2]);
if false then // TODO: understand all this?
		e:=Split(s, "=");
		// e[2] = "1: ramified, e"
		i:=Split(e[2], ":");
		i:=StringToInteger(i[1]);
		// e[3] = "3) ; easy."
		e:=Split(e[3], ")");
		e:=StringToInteger(e[1]);
		// in the abelian case, i*e*f = n
		f:=Degree(K) div (i*e);
		bad[#bad+1]:=<pp, i, e, f>;
else
		bad[#bad+1]:=<pp>;
end if;
	    else
	        error("Case not easy NYI");
	    end if;
	end while;
	return bad;
end function;

// OUTPUT: r(Z) s.t. r(Z) generates Gal(f).
CyclicAction := function(K)
        t:=K.1;
	KZ<Z>:=PolynomialRing(K);
	fZ:=KZ!Eltseq(DefiningPolynomial(K));
	lr:=Roots(fZ); // lr = [<t, 1>, ...]
//	print lr;
	for i:=1 to #lr do
	    if lr[i][1] eq t then continue; end if;
	    // check for order
	    r:=lr[i][1];
	    rZ:=KZ!Eltseq(r);
	    rj:=r;
	    ord:=1;
	    for j:=1 to Degree(K) do
	        rj:=Evaluate(rZ, rj);
//		printf "r_%o = %o\n", j, rj;
		if rj eq r then break; end if;
		ord:=ord+1;
	    end for;
	    if ord eq Degree(K) then break; end if;
	end for;
	return rZ;
end function;

GeneratorForBad := function(K, OK, p, id)
	lf:=Factorization(id);
	printf "# lf(%o | %o)=%o\n", id, p, lf;
	if #lf ne 1 then error("PB??"); end if;
	ok,gp:=IsPrincipal(lf[1][1]);
	if not ok then error("Not principal"); end if;
	// lf[1][2] is the ramification index
	return <K!gp, lf[1][2], Degree(lf[1][1])>;
end function;

PrintGenerator := procedure(fo, i, gef)
	gp,ep,fp:=Explode(gef);
	den:=Denominator(gp);
	tmp:=Eltseq(den*gp);
	fprintf fo, "%o", i;
	if ep eq 1 and fp eq 1 then
	    // ordinary case
	    fprintf fo, " %o", den;
	else
	    fprintf fo, " %o %o", -ep, fp;
	    fprintf fo, " %o", den;
	end if;
	for j:=1 to #tmp do
	    fprintf fo, " %o", tmp[j];
	end for;
	fprintf fo, "\n";
end procedure;

// sigma([p, alpha-r]) = [p, sigma(alpha)-r]
// = [p, alpha-sigma^(-1)(r)]
CyclicGetGenerator := function(ca, den, tca, p, r, rr, gp)
	K:=Parent(Coefficient(ca, 0));
	Fp:=GF(p);
        cap:=PolynomialRing(Fp)!Eltseq(den * ca);
	cap:=cap / (Fp!den);
	sh:=0;
	while sh le Degree(K) do
	    sh:=sh+1;
	    rr:=Evaluate(cap, rr);
	    printf "sh = %o => rr = %o\n", sh, rr;
	    if rr eq r then
	        break;
	    end if;
	end while;
	if sh gt Degree(K) then
	    error("too many iterations in CyclicGetGenerator");
	end if;
	for ss:=1 to Degree(K)-sh do
	    gpZ:=Parent(ca)!Eltseq(gp);
	    gp:=Evaluate(gpZ, tca);
	end for;
	return gp;
end function;

// algpr contains lines "i p r" for algebraic primes (in hexa).
// SIDE-EFFECT: fill in file 'generators' with generators.
// TODO: separate bad primes.
GeneratorsForPRPlain := procedure(~GEN,~BAD,K,OK,U,badidealinfo,algpr,generators)
	tp:=Cputime();
        bad:=ReadBadIdeals(K, badidealinfo);	       
	badp:=[x[1] : x in bad];
	printf "# bad ideals=%o => badp=%o\n", bad, badp;
	printf "# Extracting (p, r) from %o\n", algpr;
	// first read algebraic ideals
        fd:=POpen("gzip -dc " * algpr, "r");
        fo:=POpen("gzip -c > " * generators, "w");
	zero:=[0 : i in [1..Degree(K)-2]];
	npr:=0;
	oldp:=0;
	oldr:=0;
	oldgp:=0;
	iscyc:=IsCyclic(GaloisGroup(DefiningPolynomial(K)));
	if iscyc then
	    // ca = poly in Z => tca = elt of K
	    printf "# cyclic Galois group\n";
	    ca:=CyclicAction(K); // can be in OK[Z], hence have a denominator
	    printf "# cyclic action: %o;\n", ca;
	    tca:=Eltseq(ca) cat [ 0 : i in [Degree(ca)+1..Degree(K)-1]];
	    tca:=K!tca;
	end if;
        while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    npr:=npr+1;
	    if npr mod 10000 eq 0 then
	        printf "# plain-computing generator for %o-th ideal at %o\n", 
		       npr, Cputime();
	    end if;
	    // s = "i p r"
	    tmp:=Split(s, " ");
	    i:=StringToInteger(tmp[1], 16);
	    p:=StringToInteger(tmp[2], 16);
	    r:=StringToInteger(tmp[3], 16);
	    if p in badp then
	        id:=ideal<OK | [p, 0] cat zero, [p-r, 1] cat zero>;
	    	GEN[i]:=GeneratorForBad(K, OK, p, id);
		gp:=GEN[i][1]; // for oldgp to work!
	    else
	        done:=false;
	        if iscyc and p eq oldp then
	 	    // use cyclic action and sigma(r) = rr (transitive stuff?)
		    if DLP_DEBUG ge 2 then
		        printf "roots=%o\n", Roots(PolynomialRing(GF(p))!Eltseq(DefiningPolynomial(K)));
		    end if;
		    den:=Lcm([Denominator(Coefficient(ca, i)) : i in [0..Degree(ca)]]);
		    if (den mod p) eq 0 then
		        printf "den = 0!!!!\n";;
			done:=false;
		    else
			gp:=CyclicGetGenerator(ca,den,tca,p,r,oldr,oldgp);
//printf "gp=%o => Norm = %o\n", gp, Norm(gp);
	 	    	if DLP_DEBUG ge 2 then
		            // sometimes we have to check basic things...
		            id:=ideal<OK | [p, 0] cat zero, [p-r, 1] cat zero>;
			    foo,bar:=IsPrincipal(id);
			    print foo, K!bar, gp, (K!bar)/gp;
		    	    if not gp in id then error("gp"); end if;
		    	end if;
			done:=true;
		    end if;
		end if;
		if not done then
		    id:=ideal<OK | [p, 0] cat zero, [p-r, 1] cat zero>;
		    ok,gp:=IsPrincipal(id);
	    	    if not ok then error("Not principal"); end if;
	    	    gp:=K!gp;
		end if;
	        GEN[i]:=<Minimize(K, U, gp), 1, 1>;
	    end if;
	    if DLP_DEBUG ge 2 then
	        printf "(p, r)=(%o, %o), gen=%o, norm(gen)=%o\n", 
	    		   p, r, GEN[i], Norm(gp);
	    end if;
//if p gt 50 then error("FF"); end if;
       	    PrintGenerator(fo, i, GEN[i]);
	    oldp:=p;
	    oldr:=r;
	    oldgp:=gp;
	end while;
	printf "#T# plain-computing all generators: %o\n", Cputime(tp);
end procedure;

ReadAlgpr := procedure(~lipr, ~pamax, algpr)
	printf "# Reading file %o\n", algpr;
        fd:=POpen("gzip -dc " * algpr, "r");
	lipr:=AssociativeArray();
	npr:=0;
        while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    npr:=npr+1;
	    if npr mod 10000 eq 0 then
	        printf "# reading %o-th ideal at %o\n", npr, Cputime();
	    end if;
	    // s = "i p r"
	    tmp:=Split(s, " ");
	    i:=StringToInteger(tmp[1], 16);
	    p:=StringToInteger(tmp[2], 16);
	    r:=StringToInteger(tmp[3], 16);
	    if IsDefined(lipr, p) then
	        lipr[p]:=Append(lipr[p], <i, r>);
	    else
	        lipr[p]:=[<i, r>];
	    end if;
	    pamax:=p;
	end while;
end procedure;

GeneratorsForPR := procedure(~GEN,~BAD,K,OK,U,badidealinfo,algpr,generators)
	if Degree(K) gt 3 then
	    GeneratorsForPRPlain(~GEN,~BAD,K,OK,U,badidealinfo,algpr,generators);
	    return;
	end if;
        bad:=ReadBadIdeals(K, badidealinfo);	       
	badp:=[x[1] : x in bad];
	printf "# bad ideals=%o => badp=%o\n", bad, badp;
	// read algpr in a table
	ReadAlgpr(~lipr, ~pamax, algpr); // useful to have in-core?
	printf "# pamax = %o\n", pamax;
	printf "# enumerating at %o\n", Cputime();
	l:=EnumeratePrimeNorms(K, OK, U, lipr, pamax);
//	printf "K:=%m;\nOK:=MaximalOrder(K);\n", K;
//	print l;
	npcp:=0;
	ndone:=0;
	printf "# inspecting at %o\n", Cputime();
	zero:=[0 : i in [1..Degree(K)-2]];
	npr:=0;
	tot:=Cputime();
	totmb:=0.0;
	for p in Sort([x : x in Keys(lipr)]) do // humf!
	  npr:=npr+1;
	  if npr mod 1000 eq 0 then
	        printf "# computing generator for %o-th ideal[%o] at %o\n", 
		       npr, p, Cputime();
	  end if;
	  for ir in lipr[p] do
	    i,r:=Explode(ir);
	    id:=ideal<OK | [p, 0] cat zero, [p-r, 1] cat zero>;
	    if p in badp then
	        printf "bad: id(<%o, %o>) = %o\n", p, r, id;
	        GEN[i]:=GeneratorForBad(K, OK, p, id);
	    else
		ok:=false;
		if IsDefined(l, p) then
		    tp:=Cputime();
//		    printf "%o: %o\n", lipr[p], #l[p];
		    for elt in l[p] do
		        if elt in id then
			    ok:=true;
			    GEN[i]:=<K!elt, 1, 1>;
			    break;
			end if;
		    end for;
//		    if not ok then printf "missed\n"; end if;
//		    printf "# membership: %o %o\n", #l[p], Cputime(tp);
		    totmb:=totmb+Cputime(tp);
		    ndone:=ndone+1;
		end if;
		if ok then
//		    printf "found: %o\n", GEN[i][1];
		    Exclude(~l[p], GEN[i][1]);
		else
//		    printf "I need to principalize: %o %o\n", p, ir;
		    tp:=Cputime();
		    ok,gp:=IsPrincipal(id);
		    tp:=Cputime(tp);
		    if tp gt 1.0 then
		        printf "#T# pcp: %o\n", tp;
		    end if;
		    if not ok then error("Not principal"); end if;
		    GEN[i]:=<K!gp, 1, 1>;// FIXME: useless since bad are known?
		    npcp:=npcp+1;
		end if;
	    end if;
//if i gt 20 then error("FFF"); end if;
	  end for;
	end for;
	printf "#T# totpcp=%o totmb=%o npcp=%o ndone=%o\n", 
	       Cputime(tot), totmb, npcp, ndone;
	tp:=Cputime();
        fo:=POpen("gzip -c > " * generators, "w");
	for i in Sort([x : x in Keys(GEN)]) do
       	    PrintGenerator(fo, i, GEN[i]);
	end for;
	printf "#T# output: %o\n", Cputime(tp);
end procedure;

// GEN[i] = x
// BAD[i] = <x, ind, deg>
ReadGeneratorsForPR := procedure(~GEN, ~BAD, K, generators)
	printf "# Reading generators for (p, r) from %o\n", generators;
	t:=K.1;
        fd:=POpen("gzip -dc " * generators, "r");
	npr:=0;
        while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    // s = "i -ram_ind ram_deg den x0 ... x_{deg-1}"
	    // or
	    // s = "i den x0 ... x_{deg-1}" with den > 0
	    tmp:=Split(s, " ");
	    i:=StringToInteger(tmp[1]);
	    ind:=StringToInteger(tmp[2]);
	    if ind gt 0 then
	        // ordinary case
		den:=ind;
		ind:=1;
		deg:=1;
		j0:=3;
	    else
	        // a bad ideal
		ind:=-ind;
	        deg:=StringToInteger(tmp[3]);
	    	den:=StringToInteger(tmp[4]);
		j0:=5;
	    end if;
	    x:=0;
	    for j:=j0 to #tmp do
	        x:=x + StringToInteger(tmp[j]) * t^(j-j0);
	    end for;
	    if j0 eq 3 then
	        GEN[i]:=x/den;
	    else
		BAD[i]:=<x/den, ind, deg>;
	    end if;
//	    printf "GEN[%o]=%o (%o)\n", i, GEN[i], Norm(GEN[i][1]);
	end while;
end procedure;

// now read all ab pairs from purged, together with the ideal numbers
// eps[(a, b)_i] <- unit for (a-b*theta) given its algebraic factorization.
// All that matters is that index i.
UnitsForPurged := procedure(~GEN,~BAD,~epsab,K,OK,U,purged)
	t:=K.1;
        fd:=POpen("gzip -dc " * purged, "r");
	s:=Gets(fd);
	// read first line: s = "# 10807 37271 10805"
	tmp:=Split(s, " ");
	nr:=StringToInteger(tmp[2]);
	lc:=StringToInteger(tmp[3]);
	nc:=StringToInteger(tmp[4]);
	printf "# nr = %o, lc = %o, nc = %o\n", nr, lc, nc;
	iab:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "-ad21b,8217:4,6,6,c,18,166,1c9,5f4,ad3,1fbc,14,8e,7e7,e23,8d73,0"
	    tmp:=Split(s, ":");
	    tmp2:=Split(tmp[1], ",");
	    a:=StringToInteger(tmp2[1], 16);
	    b:=StringToInteger(tmp2[2], 16);
//	    printf "# s = %o\n", s;
//	    printf "a-b*m=%o\n", Factorization(Integers()!(a-b*m));
//	    printf "Norm(a-b*t)=%o\n", Factorization(Integers()!Norm(a-b*t));
//	    printf "lf = %o\n", Factorization((a-b*t)*OK);
	    tmp2:=Split(tmp[2], ",");
	    // among these, we have rational or algebraic primes
	    li:=[];
	    oldi:=-1;
	    exi:=1;
	    for stri in tmp2 do
	    	i:=StringToInteger(stri, 16);
	        if not IsDefined(GEN, i) and not IsDefined(BAD, i) then
		    continue;
		end if;
		if i eq oldi then
		    exi:=exi+1;
		elif oldi ne -1 then
		    li[#li+1]:=<oldi, exi>;
		    exi:=1;
		end if;
		oldi:=i;
	    end for;
	    if oldi ne -1 then
	        li[#li+1]:=<oldi, exi>;
	    end if;
	    prod:=1;
	    for iexi in li do
	        i,exi:=Explode(iexi);
		if IsDefined(GEN, i) then
		    if DLP_DEBUG ge 2 then
		        printf "multiplying by GEN[%o]^e=%o^%o",i,GEN[i],exi;
		        printf " of norm %o\n", Norm(GEN[i]);
		    end if;
		    prod:=prod * GEN[i]^exi;
		elif IsDefined(BAD, i) then
		    if DLP_DEBUG ge 2 then
		        printf "multiplying by BAD[%o]^e=%o^%o", 
			       i, BAD[i][1], exi div BAD[i][3];
		        printf " of norm %o\n", Norm(BAD[i][1]);
		    end if;
		    prod:=prod * BAD[i][1]^(exi div BAD[i][3]);
		end if;
	    end for;
	    eta:=(a-b*t)/prod;
	    if DLP_DEBUG ge 2 then
	        printf "eta=%o => Norm=%o\n", eta, Norm(eta);
	    end if;
	    iab:=iab+1;
	    epsab[iab]:=RecoverUnits(U, K, OK!eta);
	    if epsab[iab] eq [] then error("No unit found"); end if;
	end while;
end procedure;

// File XXX.index
// ==============
// 
// Is is created by replay, and contains the link between the rows of the
// small matrix (coming out from merge/replay) and the relation sets to
// which they correspond.
// 
// The first line gives number of rows (relation-sets) and columns (ideals)
// after the merge/replay.
// 
// Then, each line of the file corresponds to a line of the small matrix:
// the first entry is an integer giving the number of relations in the
// relation-set, and the rest of the line gives the indices of the relations
// (in hexadecimal). These indices relate to the numbers of the lines in the
// purged.gz file.
// 
// For DL, each entry is of the form id:e, where id is the index in the
// purged.gz file, and e is the exponent of the corresponding relation in
// the relation-set.
DLProduceUnits := procedure(~mat, purged, index, rK, FB, epsab)
	ab:=DLReadPurged(purged);
        fd:=POpen("gzip -dc " * index, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	small_ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, small_ncols;
	i:=0;
	eps:=[0] cat [0 : j in [1..rK]];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "3 2c:-1 98:1 a7b:1"
	    tmp:=Split(s, " ");
	    nab:=StringToInteger(tmp[1]);
	    i:=i+1;
	    if i mod 10000 eq 0 then
	        printf "## relation-set %o at %o\n", i, Cputime();
	    end if;
	    for	u:=1 to rK+1 do eps[u]:=0; end for;
	    for k:=1 to nab do
	        // tmp[k+1] = "2c:-1"
		foo:=Split(tmp[k+1], ":");
		id:=1 + StringToInteger(foo[1], 16);
		e :=StringToInteger(foo[2]);
		if ab[id][2] eq 0 then
		    // free relation
		    eta:=FB[ab[id][1]][2];
		    if DLP_DEBUG ge 2 then
		        printf "freerel: %o^e=%o^%o\n", ab[id], eta, e;
		    end if;
		else
		    eta:=epsab[ab[id]];
		    if DLP_DEBUG ge 2 then
		        printf "%o^e=%o^%o\n", ab[id], eta, e;
		    end if;
		end if;
		// update units
		for u:=1 to rK+1 do
		    eps[u]:=eps[u] + e * eta[u];
		end for;
	    end for;
	    if DLP_DEBUG ge 2 then
	        printf "eps(R%o)=%o\n", i, eps;
	    end if;
	    // we don't care about the sign of eps...
	    mat[i]:=eps[2..rK+1];
	end while;
end procedure;

// epsab[i] = unit for (a, b)_i for i in index.
DLProduceUnits2 := procedure(~mat, index, rK, epsab)
        fd:=POpen("gzip -dc " * index, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	small_ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, small_ncols;
	i:=0;
	eps:=[0] cat [0 : j in [1..rK]];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "3 2c:-1 98:1 a7b:1"
	    tmp:=Split(s, " ");
	    nab:=StringToInteger(tmp[1]);
	    i:=i+1;
	    if i mod 10000 eq 0 then
	        printf "## relation-set %o at %o\n", i, Cputime();
	    end if;
	    for	u:=1 to rK+1 do eps[u]:=0; end for;
	    for k:=1 to nab do
	        // tmp[k+1] = "2c:-1"
		foo:=Split(tmp[k+1], ":");
		id:=1 + StringToInteger(foo[1], 16);
		e :=StringToInteger(foo[2]);
		eta:=epsab[id];
		// update units
		for u:=1 to rK+1 do
		    eps[u]:=eps[u] + e * eta[u];
		end for;
	    end for;
	    if DLP_DEBUG ge 2 then
	        printf "eps(R%o)=%o\n", i, eps;
	    end if;
	    // we don't care about the sign of eps...
	    mat[i]:=eps[2..rK+1];
	end while;
end procedure;

// read from .poly
ReadDataFromPolyFile := function(name)
	fd:=Open(name, "r");
	f:=0;
	g:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    tmp:=Split(s, " ");
	    if #tmp eq 2 then
	        if tmp[1] eq "n:" then
	            p:=StringToInteger(tmp[2]);
	    	elif tmp[1] eq "m:" then
		    m:=StringToInteger(tmp[2]);
		elif tmp[1][1] eq "c" then
		    // tmp[1] = "c0:"
		    i:=StringToInteger(tmp[1][2]); // humf!
		    f:=f+StringToInteger(tmp[2]) * X^i;
		elif tmp[1][1] eq "Y" then
		    // tmp[1] = "Y0:"
		    i:=StringToInteger(tmp[1][2]); // humf!
		    g:=g+StringToInteger(tmp[2]) * X^i;
		end if;
	    end if;
	end while;
	printf "## check f, g, f(m), g(m): ";
	printf "%o, %o, %o, %o\n", f, g, (Integers()!Evaluate(f, m)) mod p,
	      (Integers()!Evaluate(g, m)) mod p;
	return p, m, f, g;
end function;

// Useful for verification.
DLReadSmallMatrix := function(small, extra, ell)
        fd:=Open(small, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, ncols;
	Fell:=GF(ell);
	M:=SparseMatrix(Fell, nrows, ncols+extra);
	i:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "16 2:1 0:1 3:1 4:2 7:1 18:1 36:1 8...."
	    // fill in row_i
	    i:=i+1;
	    tmp:=Split(s, " ");
	    nk:=StringToInteger(tmp[1]);
	    for k:=1 to nk do
	        // tmp[k+1] = "2:1"
		foo:=Split(tmp[k+1], ":");
		j:=1 + StringToInteger(foo[1]);
		M[i, j]:=Fell ! StringToInteger(foo[2]);
	    end for;
	end while;
	return M;
end function;

// Used for verification only.
DLReadSM := procedure(~M, sm, rK)
        fd:=Open(sm, "r");
	// read first line: small_nrows
	s:=Gets(fd);
	nr:=StringToInteger(s);
	assert(nr eq NumberOfRows(M));
	ncols:=NumberOfColumns(M);
	Fell:=Parent(M[1, 1]);
	i:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "26476811979143817355732776187682666169 5914672..."
	    i:=i+1;
	    tmp:=Split(s, " ");
	    for k:=1 to rK do
	        M[i, ncols-rK+k]:=StringToInteger(tmp[k]);
	    end for;
	end while;	
end procedure;

UnitsWithParams := function(FB, epsab, G, GEN, BAD, gen_epsab, params)
	p,m,f,g:=ReadDataFromPolyFile(params["poly"]);
        if DLP_VERIFICATION then
	    ell:=params["ell"];
	end if;
	K<t>:=ext<QQ | f>;
	OK:=MaximalOrder(K);
	U:=AssociativeArray();
	PrepareUnits(~U,~G,K,OK,gen_epsab);
	U["grouptable"]:=G;
	rK:=U["rK"];
	if gen_epsab then
	    FB:=AssociativeArray();
	    GEN:=AssociativeArray();
	end if;
        if DLP_VERIFICATION then
	    printf "# Reading small matrix\n";
	    small:=params["small"];
	    mat:=DLReadSmallMatrix(small, rK, ell);
	    printf "# Glue-ing sm matrix\n";
	    DLReadSM(~mat, params["sm"], rK);
	    ncols:=NumberOfColumns(mat);
	    printf "# Now computing kernel of %o x %o for debug/fun\n",ncols,ncols;
	    return NullspaceOfTransposeMatrix(ExtractBlock(mat,1,1,ncols,ncols));
 	end if;
// OBSOLETE
        // space for rK units (we don't care about signs...!)
//	mat:=DLReadSmallMatrix(small, rK, ell);
//      fb:=params["fb"];
//	if gen_epsab then // humf!
//	    ReadFactorBase(~FB, K, OK, U, fb, Degree(f));
//	end if;

        purged:=params["purged"];
	if gen_epsab then
	    BAD:=AssociativeArray();
	    epsab:=AssociativeArray();
	    if IsDefined(params, "relsdir") then
	    	TreatFromDir(~FB,~epsab,p,f,g,m,K,OK,U,params["relsdir"]);
	    elif IsDefined(params, "algpr") then
	        GeneratorsForPR(~GEN,~BAD,K,OK,U,params["badidealinfo"],
				params["algpr"],params["generators"]);
		UnitsForPurged(~GEN,~BAD,~epsab,K,OK,U,purged);
	    end if;
	    return FB,epsab,G,GEN,BAD; // OHHHHHHHHHHHHHHHH!
	else
	    printf "# epsab already computed\n";
	end if;

	tp:=Cputime();
	index :=params["index"];
	mat:=[];
	if IsDefined(params, "relsdir") then
 	    DLProduceUnits(~mat, purged, index, #U["units"], FB, epsab);
	else
 	    DLProduceUnits2(~mat, index, #U["units"], epsab);
	end if;
	printf "#T# producing units: %o\n", Cputime(tp);
	nrows:=#mat;
	// last two cols should be plenty of eps values...!
	ficunits:=params["ficunits"];
	printf "## outputting units to file %o\n", ficunits;
	fd:=Open(ficunits, "w");
	fprintf fd, "%o\n", nrows;
	for i:=1 to nrows do
	    // only rK components, we don't care about the sign!
	    for j:=1 to rK do
	        fprintf fd, "%o", mat[i][j];
		if j lt rK then fprintf fd, " "; end if;
	    end for;
	    fprintf fd, "\n";
	end for;
        return [];
end function;

// ell:=63682780151674075656521332710720136307;
// FB,epsab,G:=UnitsFromCADO("SNFS", "p59", ell, [], [], [], true);
// UnitsFromCADO("SNFS", "p59", ell, FB, epsab, G, false);
UnitsFromCADO := function(dir, name, ell, FB, epsab, G, GEN, BAD, gen_epsab)
        params:=AssociativeArray();
	if DLP_VERIFICATION then
	    params["ell"]:=ell;
	    params["small"]:=dir * "/" * name * ".merge.small.txt";
	    params["sm"]:=dir * "/" * name * ".sm.sm";
	end if;
        // "p59"  ===> "SNFS/p59/"
	dir:=dir * "/" * name;
	params["poly"]:=dir * "/" * name * ".polyselect.poly";

	// not needed, actually
	// fb = "SNFS/p59/p59.factorbase.roots"
	// params["fb"]:=dir * "/" * name * ".factorbase.roots.gz";

        // "p59"  ===> "SNFS/p59/p59.upload/p59"
// 	params["relsdir"]:=dir * "/" * name * ".upload/" * name;
	params["renumber"]:=dir * "/" * name * ".freerel.renumber.gz";
	params["algpr"]:=dir * "/" * name * ".algpr.gz";
	params["generators"]:=dir * "/" * name * ".generators.gz";
	params["purged"]:=dir * "/" * name * ".purge.purged.gz";
	params["index"]:=dir * "/" * name * ".merge.index.gz";
	params["ficunits"]:=dir * "/" * name * ".units.units";
	return UnitsWithParams(FB, epsab, G, GEN, BAD, gen_epsab, params);
end function;

// ComputeUnits("SNFS", "p59", 63682780151674075656521332710720136307);
// ComputeUnits("SNFS", "p60-2", 13);
// ComputeUnits("SNFS", "p65d5", 13);
ComputeUnits := procedure(dir, name, ell)
	FB,epsab,G,GEN,BAD:=UnitsFromCADO(dir,name,ell,[],[],[],[],[],true);
	UnitsFromCADO(dir, name, ell, FB, epsab, G, GEN, BAD, false);
end procedure;

// If generate = true, we must build algpr and generators.
ComputeUnitsFromWrapper := procedure(polyfile,renumber,algpr,generators,badidealinfo,purged,index,ficunits,generate)
        params:=AssociativeArray();

	params["poly"]:=polyfile;

// 	params["relsdir"]:=relsdir;
	params["renumber"]:=renumber;
	params["algpr"]:=algpr;
	params["generators"]:=generators;
	params["badidealinfo"]:=badidealinfo;

	params["purged"]:=purged;
	params["index"]:=index;
	params["ficunits"]:=ficunits;

	FB:=[];
	GEN:=AssociativeArray();
	BAD:=AssociativeArray();
	p,m,f,g:=ReadDataFromPolyFile(params["poly"]);
	K<t>:=ext<QQ | f>;
	OK:=MaximalOrder(K);
	printf "OK = %o\n", [K!OK.i : i in [1..Degree(K)]];
	U:=AssociativeArray();
	PrepareUnits(~U, ~G, K, OK, true);
	U["grouptable"]:=G;
	if generate then
	    GeneratorsForPR(~GEN,~BAD,K,OK,U,params["badidealinfo"],
			    params["algpr"],params["generators"]);
	else
	    BAD:=AssociativeArray();
	    ReadGeneratorsForPR(~GEN, ~BAD, K, generators);
	    printf "# bad primes = %o\n", Keys(BAD);
	    epsab:=AssociativeArray();
	    UnitsForPurged(~GEN,~BAD,~epsab,K,OK,U,purged);
	    UnitsWithParams(FB, epsab, G, GEN, BAD, false, params);
	end if;
end procedure;

Simul := procedure(dir, name, gen)
        // "p59"  ===> "SNFS/p59/"
	dir:=dir * "/" * name;
	poly:=dir * "/" * name * ".polyselect.poly";
	renumber:=dir * "/" * name * ".freerel.renumber.gz";
	algpr:=dir * "/" * name * ".algpr.gz";
	generators:=dir * "/" * name * ".generators.gz";
	purged:=dir * "/" * name * ".purge.purged.gz";
	index:=dir * "/" * name * ".merge.index.gz";
	ficunits:=dir * "/" * name * ".units.units";
	bad:=dir * "/" * name * ".magmanmbrthry.badidealinfo";

	if gen then
	    printf "# compute generators\n";
	    ComputeUnitsFromWrapper(poly,renumber,algpr,generators,bad,
				    purged,index,ficunits,true);
	end if;
	printf "# compute units for file %o\n", purged;
	ComputeUnitsFromWrapper(poly,renumber,algpr,generators,bad,
				purged,index,ficunits,false);
end procedure;

ComputeUnitsFromWrapper(polyfile,renumber,algpr,generators,badidealinfo,purged,index,ficunits,ww eq "true"); // don't ask why we should write this...!
exit;
