/*
Wrapper version, to be used with
  magma -b polyfile:=$POLY renumber:=$RENUMBER algpr:=$ALGPR generators:=$GENERATORS badideals:=BADIDEALS purged:=$PURGED index:=$INDEX ficunits:=$FICUNITS ww:=true/false $DIR/nfsunits.mag
*/

//
// author: morain@lix.polytechnique.fr 
//
// Using units in (S)NFS-DL

NFSUNITS_VERSION:="20140321.2045"; // first trial with h > 1
NFSUNITS_VERSION:="20140324.1745"; // Minimize works now for all rK
NFSUNITS_VERSION:="20140327.0730"; // more cleaning w.r.t. U
NFSUNITS_VERSION:="20140329.1930"; // computing m + other stuff
NFSUNITS_VERSION:="20140402.1830"; // ready for GF(p^2)
NFSUNITS_VERSION:="20140402.2100"; // patching while waiting for Cyril
NFSUNITS_VERSION:="20140403.1830"; // after Cyril's modifs
NFSUNITS_VERSION:="20140410.1645"; // ready to shoot
NFSUNITS_VERSION:="20140702.1830"; // degree 6, etc.

printf "## NFSUNITS_VERSION %o\n", NFSUNITS_VERSION;
// SetDebugOnError(true);

QQ:=Rationals();
QX<X>:=PolynomialRing(QQ);
QXT<T>:=PolynomialRing(QX);

// load "cyclicpoly.mag";

DLP_USE_UNITS_FLOAT:=true;
R20:=RealField(20);
C20:=ComplexField(R20);
RR:=RealField(80);
RRY<Y>:=PolynomialRing(RR);
CC:=ComplexField(RR);
CCZ<Z>:=PolynomialRing(CC);

DLP_DEBUG:=1;
DLP_VERIFICATION:=false; // for expert debug mode only...

SetColumns(0);
SetDebugOnError(true);

// precompute all products of units^ex with |ex| <= bound.
BuildGroupTable := function(units, bounds)
        if DLP_DEBUG ge 2 then
	    printf "# BSGT --> %o at %o\n", units, Cputime();
	end if;
	G:=AssociativeArray();
	if #units eq 1 then
	    for i:=-bounds[1] to bounds[1] do
	        G[units[1]^i]:=[i];
	    end for;
	else
	    GG:=$$(units[1..#units-1], bounds);
	    for i:=-bounds[#units] to bounds[#units] do
	        prod:=units[#units]^i;
		for pr in Keys(GG) do
		    G[prod * pr]:=GG[pr] cat [i];
		end for;
	    end for;
	end if;
	if DLP_DEBUG ge 2 then
 	    printf "# <-- BSGT %o at %o\n", units, Cputime();
	end if;
	return G;
end function;

// x in K, so a poly in t -> real poly.
AlgToReal := function(x)
        return RRY ! [ RR ! y : y in Eltseq(x)];
end function;

// x in K, so a poly in t -> real poly.
AlgToComplex := function(x)
        return CCZ ! [ CC ! y : y in Eltseq(x)];
end function;

// For elt in K.
AllEmbeddings := function(Kdata, x)
	K:=Kdata["K"];
	rK:=Kdata["rK"];
	if rK eq Degree(K)-1 then
    	    rx:=AlgToReal(x);
	    return [Log(Abs(Evaluate(rx, R20!z))) : z in Kdata["roots"]];
	elif 2*rK+2 eq Degree(K) then
    	    rx:=AlgToComplex(x);
	    return [Log(Abs(Evaluate(rx, z))) : z in Kdata["roots"]];
	else
	    error("Pb in AllEmbeddings");
	end if;
end function;

// basis = {omega_i}, dual = {omega_i^*}.
ComputeDualBasis := function(K, OK)
	n:=Degree(K);
	T:=KMatrixSpace(QQ, n, n)!0;
        for i:=1 to n do
	    for j:=1 to n do
	        T[i, j]:=Trace(OK.i * OK.j);
	    end for;
	end for;
//	printf "# T=\n%o\n", T;
	return T^(-1);
end function;

// OUTPUT: bounds for alpha in OK, |Norm(alpha)| <= B.
// Based on FiPo + BoCh, with more care.
// TODO: better?
FiPoBounds := function(B, Kdata, logunits)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	n:=Degree(K);
	// compute FiPo bounds
        U:=[];
	for i:=1 to n do
	    U[i]:=&+ [Abs(logunits[j][i]) : j in [1..#logunits]];
	    U[i]:=Exp((Log(B)/n) + 0.5 * U[i]);
	end for;
	printf "# FiPi.U = %o\n", U;
	// use dual basis
	D:=ComputeDualBasis(K, OK);
//	printf "# dual basis:\n%o\n", D;
	// use embeddings to get a bound on |sigma_i(omega_j^*)|
	bounds:=[];
	for j:=1 to n do
	    // omega_j^* = j-th column of D
	    ojs:=&+ [ OK.i * D[i, j] : i in [1..n]];
	    alljs:=AllEmbeddings(Kdata, K!ojs);
//	    printf "# omega_%o^*: %o\n", j, alljs;
	    bounds[j]:=Truncate(&+ [U[i] * Abs(alljs[i]) : i in [1..n]]);
	end for;
	printf "# bounds found: %o\n", bounds;
//	return bounds;
	if n eq 3 then
//	    return [125 : i in [1..n]];
	    return [20 : i in [1..n]];
	elif n eq 4 then
	    return [20 : i in [1..n]];
	elif n eq 5 then
	    return [20 : i in [1..n]];
	elif n eq 6 then
	    return [10 : i in [1..n]];
	else
	    return [20 : i in [1..n]];
	end if;
end function;

// Use LLL? Obsolete?
MinimizeTry := function(Kdata, x, lx)
	rK:=Kdata["rK"];
	U:=Kdata["UK"];
	nU:=#U["logunits"];
	n:=Degree(Kdata["K"]);
	M:=KMatrixSpace(R20, n, nU)!0;
	for i:=1 to n do M[i, 1]:=lx[i]; end for;
	for j:=1 to nU do
	    for i:=1 to n do
	        M[i, j+1]:=U["logunits"][j][i];
	    end for;
	end for;
//	print M;
	Mred,T,rg:=LLL(M);
	// Mred = T * M, T unimodular
	// col 1 of T is [t11 t21 ... tr1]
	// x^t11*eps1^t21*...*epsr^tr1
	printf "T=\n%o\n", T;
	xx:=&* [U["units"][i]^T[1, i+1] : i in [1..nU]];
	if T[1, 1] eq 1 then
	    xx:=x*xx;
	elif T[1, 1] eq -1 then
	    xx:=xx/x;
	else error("Not possible");
	end if;
	printf "xx=%o\n", xx;
end function;

// Any rK.
Minimize := function(Kdata, x)
	lx:=AllEmbeddings(Kdata, Kdata["K"]!x);
	U:=Kdata["UK"];
	rK:=Kdata["rK"];
	n:=Degree(Kdata["K"]);
	units:=U["units"];
	y:=U["logunits"];
	Rr<[a]>:=PolynomialRing(R20, rK);
	f:=&+ [ (lx[i]- (&+ [a[j]*y[j, i] : j in [1..rK]]))^2 : i in [1..n]];
	df:=[Derivative(f, i) : i in [1..rK]];
//	printf "f:=%o;\n", f;
//	printf "df = %o\n", df;
	M:=KMatrixSpace(R20, rK, rK)!0;
	for i:=1 to rK do
	    for j:=1 to rK do
	        M[i, j]:=Coefficient(df[i], a[j], 1);
	    end for;
	end for;
//	print M;
	invM:=M^(-1);
	c:=[];
	for i:=1 to rK do
	    tmp:=df[i];
	    for j:=1 to rK do
	        tmp:=Coefficient(tmp, a[j], 0);
	    end for;
	    c[i]:=R20!tmp;
	end for;
	amin:=[- (&+ [ invM[i, j] * c[j] : j in [1..rK]]) : i in [1..rK]];
//	printf "amin:=%o;\n", amin;
//	printf "f(min)=%o\n", Evaluate(f, amin);
//	printf "f(min)=%o\n", Evaluate(f, [Round(a1min), Round(a2min)]);
//	printf "f(min)=%o\n", Evaluate(f, [Truncate(a1min), Truncate(a2min)]);
//	error("DD");
	amin:=[Round(amin[i]) : i in [1..rK]];
//	printf "amin = %o\n", amin;
	u:=&* [ units[i]^amin[i] : i in [1..rK] ];
        return x/u;
end function;

// If K is Galois, only one generator has to be stored and the other
// deduced via Galois action; and the first one is enough, no division...
InsertInBox := procedure(~l, Kdata, elt, lipr, pmax)
	no:=Integers() ! Abs(Norm(elt));
	if IsDefined(lipr, no) then // meaning no is prime...!
//	    printf "elt=%o no=%o\n", elt, no;
	    if not IsDefined(l, no) then
	        l[no]:=[elt^Kdata["hK"]]; // what a trick!
	    // terrific hack: store one elt per norm in the Galois case!!!!
	    elif (not IsDefined(Kdata, "Galois"))
	    	 and (#l[no] lt Degree(Kdata["K"])) then
	        // l[no] contains distinct prime ideals
		ok:=true;
		// if elt/x is never an integer we gain a new factor
		for i:=1 to #l[no] do
		    x:=l[no][i];
		    r:=elt/x;
		    if IsIntegral(r) then
		        ok:=false;
			break;
		    end if;
		end for;
		if ok then
	 	    l[no]:=Append(l[no], elt);
		end if;
//if #l[no] gt 2 then print l[no]; error("TTTT"); end if;
	    end if;
	end if;
end procedure;

// Perhaps a more carefully used ellipsoid would be better?
EPN3 := function(Kdata, lipr, bounds, pmax)
        OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a0:=0 to bounds[1] do
	    printf "# a0 = %o at %o\n", a0, Cputime();
	    for a1:=-bounds[2] to bounds[2] do
	        for a2:=-bounds[3] to bounds[3] do
		    elt:=a0*OK.1+a1*OK.2+a2*OK.3;
		    InsertInBox(~l, Kdata, elt, lipr, pmax);
	    	end for;
	    end for;
	end for;
	printf "#T# EPN3: %o\n", Cputime(tp);
	return l;
end function;

EPN4 := function(Kdata, lipr, bounds, pmax)
       	OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a0:=0 to bounds[1] do
	    printf "# a0 = %o at %o\n", a0, Cputime();
	    for a1:=-bounds[2] to bounds[2] do
	        for a2:=-bounds[3] to bounds[3] do
	 	    for a3:=-bounds[4] to bounds[4] do
		    	elt:=a0*OK.1+a1*OK.2+a2*OK.3+a3*OK.4;
			InsertInBox(~l, Kdata, elt, lipr, pmax);
	 	    end for;
	    	end for;
	    end for;
	end for;
	printf "# time for EPN4: %o\n", Cputime(tp);
	return l;
end function;

EPN5 := function(Kdata, lipr, bounds, pmax)
       	OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a0:=0 to bounds[1] do
	    printf "# a0 = %o at %o\n", a0, Cputime();
	    for a1:=-bounds[2] to bounds[2] do
	        for a2:=-bounds[3] to bounds[3] do
	 	    for a3:=-bounds[4] to bounds[4] do
		        for a4:=-bounds[5] to bounds[5] do
		    	    elt:=a0*OK.1+a1*OK.2+a2*OK.3+a3*OK.4+a4*OK.5;
			    InsertInBox(~l, Kdata, elt, lipr, pmax);
	 	    	end for;
	 	    end for;
	    	end for;
	    end for;
	end for;
	printf "# time for EPN5: %o\n", Cputime(tp);
	return l;
end function;

EPN6 := function(Kdata, lipr, bounds, pmax)
       	OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a0:=0 to bounds[1] do
	  printf "# a0 = %o at %o\n", a0, Cputime();
	  elt0:=a0*OK.1;
	  for a1:=-bounds[2] to bounds[2] do
	    printf "# a1 = %o at %o\n", a1, Cputime();
	    elt1:=elt0+a1*OK.2;
	    for a2:=-bounds[3] to bounds[3] do
	      elt2:=elt1+a2*OK.3;
	      for a3:=-bounds[4] to bounds[4] do
	        elt3:=elt2+a3*OK.4;
		for a4:=-bounds[5] to bounds[5] do
		  elt4:=elt3+a4*OK.5;
		  for a5:=-bounds[6] to bounds[6] do
		    elt5:=elt4+a5*OK.6;
		    InsertInBox(~l, Kdata, elt5, lipr, pmax);
	 	  end for;
	 	end for;
	      end for;
	    end for;
	  end for;
	end for;
	printf "# time for EPN6: %o\n", Cputime(tp);
	return l;
end function;

// OUTPUT: l s.t. l[p] is an element of norm p.
EnumeratePrimeNorms := function(Kdata, lipr, pmax)
        tt:=Cputime();
        U:=Kdata["UK"];		    
	bounds:=FiPoBounds(pmax, Kdata, U["logunits"]);
	printf "# bounds = %o\n", bounds;
	degK:=Degree(Kdata["K"]);
        if degK eq 3 then l:=EPN3(Kdata, lipr, bounds, pmax);
        elif degK eq 4 then l:=EPN4(Kdata, lipr, bounds, pmax);
        elif degK eq 5 then l:=EPN5(Kdata, lipr, bounds, pmax);
        elif degK eq 6 then l:=EPN6(Kdata, lipr, bounds, pmax);
	end if;
	printf "# Card(l)=%o\n", #Keys(l);
if false then
	for no in Keys(l) do
	    if #l[no] lt degK then
	        printf "incomplete: l[%o], %o\n", no, #l[no];
	    end if;
	end for;
end if;
	printf "# entering minimization of generators\n";
	tp:=Cputime();
	for no in Keys(l) do
	    l[no]:=[Minimize(Kdata, x) : x in l[no]];
	end for;
	printf "#T# minimizing generators: %o\n", Cputime(tp);
	printf "#T# enumerating prime norms: %o\n", Cputime(tt);
	return l; 
end function;

// OUTPUT: r(Z) s.t. r(Z) generates Gal(f).
GaloisAction := function(K, iscyc)
        t:=K.1;
	KZ<Z>:=PolynomialRing(K);
	fZ:=KZ!Eltseq(DefiningPolynomial(K));
	lr:=Roots(fZ); // lr = [<t, 1>, ...]
//	print lr;
	sigma:=[];
	for i:=1 to #lr do
	    if lr[i][1] eq t then continue; end if;
	    // check for order
	    r:=lr[i][1];
	    rZ:=KZ!Eltseq(r);
	    rj:=r;
	    ord:=1;
	    cyc:=[rZ];
	    for j:=1 to Degree(K) do
	        rj:=Evaluate(rZ, rj);
//		printf "r_%o = %o\n", j, rj;
		if rj eq r then break; end if;
		ord:=ord+1;
		Append(~cyc, KZ!Eltseq(rj));
	    end for;
	    if ord eq Degree(K) then return [cyc]; end if;
	    Append(~sigma, cyc);
	end for;
	printf "# non-cyclic Galois: %o\n", sigma;
	return sigma;
end function;

// We need fundamental units, and in some cases, we want always the same
// answer.
// If r1 > 0, u0 = -1 is a unit.
// Torsion units are ignored, since their logs are 0 mod ell.
// OUTPUT: units[1..rK+1], orders
// where units[1] is the torsion unit (if none, then units[1] = 1) and
// units[2..rK+1] are fundamental units.
GetUnits := function(K, OK)
	if DefiningPolynomial(K) eq X^4+1 then
	    printf "# K = Q(zeta_8)\n";
	    return [OK!K.1, OK!(K.1^2-K.1+1)], [8, 0];
	end if;
	UK,map:=UnitGroup(K);
	units:=[];
	ord:=[];
	// torsion unit first
	for gen in Generators(UK) do
	    if Order(gen) ne 0 then
	        units[#units+1]:=OK!map(gen);
		ord[#ord+1]:=Order(gen);
		printf "torsion: %o %o\n", units[#units], ord[#ord];
	    end if;
	end for;
	// units of infinite order
	for gen in Generators(UK) do
	    if Order(gen) eq 0 then
	        units[#units+1]:=OK!map(gen);
		ord[#ord+1]:=0;
	    end if;
	end for;
	printf "# units = %o\n", units;
	return units, ord;
end function;

// u_1, ..., u_ell with ell = r1+r2-1; if r1 > 0, u0 = -1.
// We suppose f has real roots alpha_1, ..., alpha_{r_1}
// and complex roots alpha_{r_1+1}, ..., alpha_n
// s.t. alpha_{r_1+r_2+j} is the complex conjugate of alpha_{r_1+j}
// for 1 <= j <= r_2. Note that r1+2*r2 = n = deg(K) = deg(f).
// For 1 <= i <= ell, varphi_i(alpha) = alpha_i.
// U["units"] will contain units in OK as EltSeq.
PrepareUnits := procedure(~U, ~G, Kdata, genG)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	r1,r2:=Signature(K);
	rK:=r1+r2-1;
	printf "# r1=%o, r2=%o => rK=%o\n", r1, r2, rK;
	lr:=Kdata["roots"];
	units,ord:=GetUnits(K, OK);
//	printf "# units_OK = %o\n", units;
	printf "# units_K = %o\n", [K!u : u in units];
	// build matrix
	M:=KMatrixSpace(RR, rK, rK)!0;
	for i:=2 to #units do
	    // fill in the i-th column
	    fui:=AlgToReal(K!units[i]);
	    if DLP_DEBUG ge 2 then
	        printf "i=%o => %o = %o\n", i, K!units[i], fui;
	    end if;
	    for j:=1 to rK do
	        M[j, i-1]:=Log(Abs(Evaluate(fui, lr[j])));
	    end for;
	end for;
//	printf "M=\n%o\n", M;
	// boxes will have bound^{2*rK} points
	if rK le 2 then bound:=20;
	elif rK le 3 then bound:=10;
	elif rK le 4 then bound:=10;
	else bound:=5; end if;
	if ord[1] ne 0 then
	    bounds:=[ord[1]] cat [bound : i in [2..#units]];
	else
	    bounds:=[bound : i in [1..#units]];
	end if;
	if genG then
	    printf "# BuildGroupTable with bound %o\n", bound;
	    tp:=Cputime();
	    G:=BuildGroupTable(units, bounds);
	    printf "#T# BGT: %o\n", Cputime(tp);
	end if;
	U["units"]:=units;
	U["rK"]:=rK;
	U["Minv"]:=M^(-1);
	U["logunits"]:=[AllEmbeddings(Kdata, K!units[i]) : i in [2..#units]];
end procedure;

// INPUT: niceK means we may compute many invariants of K.
// OUTPUT: { Galois, K, roots, rK, hK, UK, OK }
PrepareField := function(K, niceK)
	r1,r2:=Signature(K);
	Kdata:=AssociativeArray();
	Kdata["K"]:=K;
	Kdata["rK"]:=r1+r2-1;
	if not niceK then return Kdata; end if;
	f:=DefiningPolynomial(K);
	if r2 eq 0 then
	    lr:=[r[1] : r in Roots(AlgToReal(f))];
	elif r1 eq 0 then
	    lr0:=[r[1] : r in Roots(AlgToComplex(f))];
	    if DLP_DEBUG ge 3 then printf "lr0=%o\n", lr0; end if;
	    // assuming that roots are [alpha1, conj(alpha1), ...]
	    // reorder them to [alpha1, alpha2, ..., alpha_r2, conj(alpha1)...]
	    lr:=[];
	    for i:=1 to r2 do
	        lr[i]:=lr0[2*i-1];
		lr[i+r2]:=lr0[2*i];
	    end for;
	else
	    // TODO: order roots of f...!
	    error("NYI in PrepareField");
	end if;
	printf "# ordered roots: %o\n", lr;
	Kdata["OK"]:=MaximalOrder(K);
	printf "OK = %o\n", [K!Kdata["OK"].i : i in [1..Degree(K)]];
	Kdata["roots"]:=lr;
	gal:=GaloisGroup(DefiningPolynomial(K));
//	printf "# Galois group:\n%o\n", gal;
	iscyc:=IsCyclic(gal);
	Kdata["Galois"]:=<iscyc, GaloisAction(K, iscyc)>;
	if iscyc then printf "# Galois(f) is cyclic\n"; end if;
//	printf "# Galois action:\n%o\n", Kdata["Galois"];
	Kdata["hK"]:=ClassNumber(K);
	printf "# hK = %o\n", Kdata["hK"];
	U:=AssociativeArray();
	PrepareUnits(~U,~G,Kdata,niceK);
	if niceK then U["grouptable"]:=G; end if; // FIXME niceK -> generate?
	Kdata["UK"]:=U;
	return Kdata;
end function;

// If x is not close enough to an integer, do not round it!
Roundify := function(x)
	prec:=Precision(x);
	ix:=Round(x);
	if Abs(ix-x) gt 10^(-0.5 * prec) then error("Precision pb?"); end if;
	return ix;
end function;

// INPUT: Keys(U) = {"grouptable", "roots", "units", "rK"}
//        eta is in OK.
// OUTPUT: [e_0, e_1, ..., e_{rK}] where eta = prod units[i]^e_i
// e_0 is the exponent of the torsion unit.
RecoverUnits := function(Kdata, eta)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	U:=Kdata["UK"];
	G:=U["grouptable"];
	if IsDefined(G, eta) then
	    return G[eta];
	end if;
//if not DLP_USE_UNITS_FLOAT or eta eq 1 or eta eq -1 then return eps; end if;
//	if DLP_DEBUG ge 2 then printf "Found eps = %o\n", eps; end if;
	rK:=U["rK"];
	lr:=Kdata["roots"];
	// don't forget to send eta in K...
	V:=[Log(Abs(Evaluate(AlgToReal(K!eta), lr[i]))) : i in [1..rK]];
	if DLP_DEBUG ge 2 then
	    printf "V = %o\n", V;
	end if;
	eps:=[];
	// compute Minv * V
	for i:=1 to rK do
	    tmp:=&+ [ U["Minv"][i, j] * V[j] : j in [1..rK] ];
	    eps[i]:=Roundify(tmp);
	    if DLP_DEBUG ge 2 then
	        printf "%o -> %o = %o\n", i, tmp, eps[i];
	    end if;
	end for;
	chk:=&* [U["units"][i+1]^eps[i] : i in [1..rK]];
	// chk/eta should be a torsion unit
	tmp:=OK!(chk/eta);
	if not IsTorsionUnit(tmp) then
	    printf "No torsion unit: %o %o -> %o\n", eta, chk, tmp;
	    error("Bad check between units");
	end if;
        printf "# floating point recovery for %o: %o, %o\n", eta, eps, tmp;
//	printf "#W# TO BE DONE: power of the torsion unit?";
//error("TBD");
	return [0] cat eps;
end function;

// lr contains the roots of f(X) mod p without multiplicity.
// WARNING: does work for easy examples only...!
// OUTPUT: [[c1, p1, e1], ..., [ck, pk, ek]], 
// e_i = ramification index, f_i = residual degree.
GetIdeals := function(K, OK, p, lr)
	lgp:=[];
	eta:=p;
	if #lr eq 1 then
	    // resort to Magma
	    r:=lr[1];
	    lf:=Factorization(p * OK);
	    printf "(%o) = %o\n", p, lf;
	    for id in lf do
	        ok,gp:=IsPrincipal(id[1]);
	    	if not ok then error("Not principal"); end if;
		// check this?
		for i:=1 to id[2] do
		    eta:=eta / gp;
		end for;
		lgp[#lgp+1]:=<r, gp, id[2]>;
	    end for;
	elif #lr eq Degree(K) then
	    tmp:=[0 : i in [1..Degree(K)-2]];
	    for r in lr do
	    	id:=ideal<OK | [p, 0] cat tmp, [p-r, 1] cat tmp>;
//	    	printf "id=%o, Norm=%o\n", id, Norm(id);
	    	ok,gp:=IsPrincipal(id);
//		printf "gen(id)=%o\n", gp;
	    	if not ok then error("Not principal"); end if;
	    	lgp[#lgp+1]:=<r, gp, 1>;
	    	eta:=eta / gp;
	    end for;
	else
	    error("#lr not permitted yet");
	end if;
	if DLP_DEBUG ge 2 then printf "lgp = %o\n", lgp; end if;
	if #lgp eq Degree(K) then
	    // a free relation
	    if DLP_DEBUG ge 2 then
	        printf "free relation: p = %o, eta = %o of norm %o\n", 
	    	   p, OK!eta, Norm(eta);
	    end if;
	end if;
	if Abs(Norm(eta)) ne 1 then error("Not a unit"); end if;
	return <lgp, OK!eta>;
end function;

// We should have f(c) = 0 mod p
UpdateFB := procedure(~FB, Kdata, U, p, c)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	f:=DefiningPolynomial(K);
        if DLP_DEBUG ge 2 then
	    printf "# computing roots of f mod %o\n", p;
	end if;
	FpX<X>:=PolynomialRing(GF(p));
	fp:=FpX!Eltseq(f);
	if Evaluate(fp, c) ne 0 then error("not a root"); end if;
if false then // false for ramified primes!!!!!
		    fp:=fp div (X-c);
		    lr:=Roots(fp);
		    lr:=[c] cat [Integers()!r[1] : r in lr];
else
	lr:=Roots(fp);
	lr:=[Integers()!r[1] : r in lr];
end if;
	FBp:=GetIdeals(K, OK, p, lr);
	if FBp[2] ne 0 then
	    // free relation: recover eps...!
	    eps:=RecoverUnits(Kdata, FBp[2]);
	    if eps eq [] then error("No unit found"); end if;
	    FBp:=<FBp[1], eps>;
	end if;
	FB[p]:=FBp;
	if DLP_DEBUG ge 2 then printf "FB[%o]=%o\n", p, FB[p]; end if;
end procedure;

// p^ex || norm.
// INPUT: FB[p] = <[<c1, gen1, e1>, ..., <ck, genk, ek>], eps_p>
// 	  where id1 = [p, p-c1], ...
//	  eta should be in OK
// Remember that (p) = p*OK = prod_{i=1}^g P_i^e_i, where Norm(P_i) = p^f_i
// and sum_i e_i f_i = n = degree(K).
// If K is abelian (e.g., cyclic), e_i = e, f_i = f and e*f*g = n.
// An inert prime is (1, n, 1).
// For non inert primes:
// n prime: (e, f, g) = (1, 1, n) or (n, 1, 1);
// n = 4: (1, 1, 4) or (2, 2, 1) or (2, 1, 2) or (1, 2, 2).
DivideGivenNorm := procedure(~eta, K, OK, FB, p, ex, c)
        n:=Degree(K);
	g:=#FB[p][1];
	// abelian case only, easy to change
	e:=FB[p][1][1][3]; // ramification index
	f:=n div (g*e);    // residual degree
	ok:=false;
	for ee:=1 to (ex div f) do
	    for id in FB[p][1] do
	    	if id[1] eq c then
	            tmp:=eta/OK!id[2];
// print id[2], tmp, Norm(tmp);
		    // this will solve the multiple roots pb
		    if IsIntegral(tmp) then
		        eta:=tmp;
		        ok:=true;
		    end if;
	    	end if;
	    end for;
	end for;
	if not ok then error("No ideal found"); end if;
end procedure;

// lf = factorization of Norm(a-b*t) = [<p1, ex1>, ...]
Treat_a_b := procedure(~FB, ~eps, Kdata, U, a, b, lf)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	t:=K.1;
	if DLP_DEBUG ge 2 then printf "a=%o, b=%o: %o\n", a, b, lf; end if;
	theta:=(a-b*t);
	eta:=OK!theta;
	for pe in lf do // code_123
	    p,ex:=Explode(pe);
	    if b mod p eq 0 then
	        error("b = 0 mod p: NYI", b);
	    else
		c:=(a * Modinv(b, p)) mod p;
		if not IsDefined(FB, p) then
		    UpdateFB(~FB, K, OK, U, p, c);
		end if;
		DivideGivenNorm(~eta, K, OK, FB, p, ex, c);
	    end if;
	    if DLP_DEBUG ge 3 then
	        printf "new theta=%o\n", eta;
	    end if;
	end for;
	eta:=OK!eta;
	if DLP_DEBUG ge 2 then
	    printf "eta=%o => Norm=%o\n", eta, Norm(eta);
	end if;
	eps:=RecoverUnits(Kdata, eta);
	if eps eq [] then error("no unit found for ", eta); end if;
	if DLP_DEBUG ge 2 then
	    printf "eps=%o\n", eps;
	end if;
end procedure;

TreatFromFile := procedure(~FB, ~epsab, p, f, g, m, Kdata, fic)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	U:=Kdata["UK"];
	t:=K.1;
        fd:=POpen("gzip -dc " * fic, "r");
	nr:=0;
	while true do
	    s:=Gets(fd);
            if IsEof(s) then break; end if;
	    // skip comments
	    if s[1] eq "#" then continue; end if;
	    // s = "88723,10093:3,3,3,3,5,1d,1af,42d,1db7,4b13,beead:13,25,e9,5029,30d51"
	    tmp:=Split(s, ":");
	    ab:=Split(tmp[1], ",");
	    nr:=nr+1;
	    if nr mod 1000 eq 0 then
	        printf "# %o relations treated at %o\n", nr, Cputime();
	    end if;
//	    printf "R%o: %o\n", nr, ab;
	    a:=StringToInteger(ab[1]);
	    b:=StringToInteger(ab[2]);

	    // recover factorization from rational part
	    // which is "3,3,3,3,5,1d,1af,42d,1db7,4b13,beead" where numbers
	    // are actual primes
	    if DLP_VERIFICATION then
	        abm:=a-b*m;
//	    	lg:=Factorization(a-b*m);
//	    	printf "lg = %o // %o\n", lg, tmp[2];
	    	rat:=Split(tmp[2], ",");
	    	lg:=[];
	        for p in rat do
	            pp:=StringToInteger(p, 16);
		    if abm mod pp ne 0 then error(abm, pp); end if;
		    abm:=abm div pp;
		    lg[#lg+1]:=pp;
	    	end for;
//	    	printf "cof(abm)=%o\n", abm;
	    	if Abs(abm) ne 1 then error("|cof| != 1"); end if;
	    end if;

	    // algebraic part: "13,25,e9,5029,30d51" where numbers are actual
	    // primes dividing the norm of a-b*t
	    no:=Integers()!Norm(a-b*t);
	    alg:=Split(tmp[3], ",");
	    lf:=[];
if false then // code_123
	    for p in alg do
	        pp:=StringToInteger(p, 16);
		if no mod pp ne 0 then error(no, pp); end if;
		no:=no div pp;
		lf[#lf+1]:=pp;
	    end for;
else // not faster! but more convenient
	    ppold:=0;
	    for p in alg do
	        pp:=StringToInteger(p, 16);
		if pp ne ppold then
	  	    ex,no:=Valuation(no, pp);
		    if ex eq 0 then error(no, pp); end if;
		    lf[#lf+1]:=<pp, ex>;
		    ppold:=pp;
		end if;
	    end for;
end if;
//	    printf "cof(no)=%o\n", no;
	    if Abs(no) ne 1 then error("|cof| != 1"); end if;

	    Treat_a_b(~FB, ~eps, Kdata, U, a, b, lf);
	    epsab[[a, b]]:=eps;
//break;
	end while;
if false then
        // compute stats here...!
	stats:=AssociativeArray();
	if IsDefined(stats, eps) then
	    stats[eps]:=stats[eps]+1;
	else
	    stats[eps]:=1;
	end if;
	for k in Keys(stats) do
	    printf "%o %o\n", stats[k], k;
	end for;
end if;
end procedure;

// U = <G, rt, funits>
// OUTPUT: epsab[a, b] = unit in factorization of a-b*alpha
TreatFromDir := procedure(~FB, ~epsab, p, f, g, Kdata, dir)

m:=0;

	tmp:=dir * ".units.listfiles";
	cmd:="ls " * dir * ".sieving* > " * tmp;
        System(cmd);
	fd:=Open(tmp, "r");
	nf:=0;
	while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    nf:=nf+1;
	    printf "## Operating on file %o: %o\n", nf, s;
	    TreatFromFile(~FB, ~epsab, p, f, g, m, Kdata, s);
	end while;
end procedure;

// Useful for verifying.
ReadFactorBase := procedure(~FB, Kdata, fb, degf)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	printf "# Reading factor base from %o\n", fb;
	f:=DefiningPolynomial(K);
	t:=K.1;
        fd:=POpen("gzip -dc " * fb, "r");
	while true do
	    s:=Gets(fd);
            if IsEof(s) then break; end if;
	    if s[1] eq "#" then continue; end if;
	    tmp:=Split(s, ":");
	    if #tmp eq 3 then 
	        if DLP_DEBUG ge 2 then printf "powers? %o\n", tmp; end if;
		continue;
	    end if;
	    p:=StringToInteger(tmp[1]);
	    tmp:=Split(tmp[2], ",");
	    // "3: 2" special???
	    if #tmp lt Degree(f) then
	        printf "ramified? p=%o => %o\n", p, tmp;
	    end if;
	    // "17: 7,13,14" normal case
	    lr:=[StringToInteger(tmp[i]) : i in [1..#tmp]];
//	    printf "p = %o => lr = %o\n", p, lr;
	    // p*OK has factors [p, t-r]
//	    printf "p*OK = %o\n", Factorization(p*OK);
	    FBp:=GetIdeals(K, OK, p, lr);
	    if FBp[2] ne 0 then
	        eps:=RecoverUnits(Kdata, FBp[2]);
          	if eps eq [] then error("No unit found"); end if;
                FBp:=<FBp[1], eps>;
	    end if;
	    FB[p]:=FBp;
	    if DLP_DEBUG ge 2 then
	        printf "FB[%o]=%o\n", p, FB[p];
	    end if;
//if p gt 50 then error("TBC"); end if;
	end while;	      
end procedure;

// From README.fileformat:
// File XXX.purged.gz
// ==================
// 
// It is created by purge, and contains a set of relations without
// singleton, and where all or almost all the excess has been used.
// 
// The first line has the following format:
// # nr lc nc
// where
//   - nr is the number of rows (relations)
//   - lc is the index of the last column (ideal) that has non-zero weight
//   - nc is the number of columns (ideals)
// nr, lc and nc are written in decimal.
// 
// Then, each line of the file corresponds to one relation: a,b:h_0,....h_k
// where
//   - a and b give the (a,b) pair of the original relation
//   - h_i is an index of an ideal appearing in the relation. For factorization, an
//     ideal appears at most one per relation. For DL, if an ideal more than
//     once in the relation, all these occurences are guaranteed to be one after
//     the other.
// a,b and the h_i's are in hexadecimal.
//
// OUTPUT: [[a, b]]
DLReadPurged := function(purged)
        ab:=[];
        fd:=POpen("gzip -dc " * purged, "r");
	s:=Gets(fd);
	// read first line: s = "# 10807 37271 10805"
	tmp:=Split(s, " ");
	nr:=StringToInteger(tmp[2]);
	lc:=StringToInteger(tmp[3]);
	nc:=StringToInteger(tmp[4]);
	printf "# nr = %o, lc = %o, nc = %o\n", nr, lc, nc;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "-ad21b,8217:4,6,6,c,18,166,1c9,5f4,ad3,1fbc,14,8e,7e7,e23,8d73,0"
	    tmp:=Split(s, ":");
	    tmp:=Split(tmp[1], ",");
	    a:=StringToInteger(tmp[1], 16);
	    b:=StringToInteger(tmp[2], 16);
	    ab[#ab+1]:=[a, b];
	end while;
	return ab;
end function;

ReadBadIdeals := function(K, badidealinfo)
	printf "# reading badidealinfo\n";
	fd:=Open(badidealinfo, "r");
	bad:=[];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    print s;
	    // s = "### 3 (2 : 1) 1 [ 1 ] (i=1: ramified, e=3) ; easy."
	    tmp:=Split(s, " ");
	    if "easy." in tmp then
		pp:=StringToInteger(tmp[2]);
if false then // TODO: understand all this?
		e:=Split(s, "=");
		// e[2] = "1: ramified, e"
		i:=Split(e[2], ":");
		i:=StringToInteger(i[1]);
		// e[3] = "3) ; easy."
		e:=Split(e[3], ")");
		e:=StringToInteger(e[1]);
		// in the abelian case, i*e*f = n
		f:=Degree(K) div (i*e);
		bad[#bad+1]:=<pp, i, e, f>;
else
		bad[#bad+1]:=<pp>;
end if;
	    else
	        error("Case not easy NYI");
	    end if;
	end while;
	return bad;
end function;

// <elt_of_K, e, f>
GeneratorForBad := function(Kdata, p, id)
	lf:=Factorization(id);
//	printf "# p=%o, id=%o => lf=%o\n", p, id, lf;
	if #lf ne 1 then error("PB??"); end if;
	lf1h:=lf[1][1]^Kdata["hK"];
	ok,gp:=IsPrincipal(lf1h);
	if not ok then error("Not principal in GeneratorForBad"); end if;
	// lf[1][2] is the ramification index
	return <Kdata["K"]!gp, lf[1][2], Degree(lf[1][1])>;
end function;

GetGeneratorFromScratch := function(Kdata, id)
	tp:=Cputime();
	ok,gp:=IsPrincipal(id^Kdata["hK"]);
	tp:=Cputime(tp);
	if tp gt 1.0 then
	    printf "#T# pcp: %o\n", tp;
	end if;
	if not ok then return false, 0, 0, 0; end if;
	tp:=Cputime();
	return true, gp, Minimize(Kdata, Kdata["K"]!gp), Cputime(tp);
end function;

GetGeneratorForqr := function(Kdata, q, r)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	zero:=[0 : i in [1..Degree(K)-2]];
	id:=ideal<OK | [q, 0] cat zero, [q-r, 1] cat zero>;
	ok,_,gen:=GetGeneratorFromScratch(Kdata, id);
	return gen;
end function;

// INPUT: fo = file descriptor
//        i = index
//        gef = <gp, ep, fp> with gp in K
PrintGenerator := procedure(fo, i, gef, isbad)
	if isbad then
	    gp,ep,fp:=Explode(gef);
	else
	    gp:=gef; ep:=1; fp:=1;
	end if;
	den:=Denominator(gp);
	tmp:=Eltseq(den*gp);
	fprintf fo, "%o", i;
	if ep eq 1 and fp eq 1 then
	    // ordinary case
	    fprintf fo, " %o", den;
	else
	    fprintf fo, " %o %o", -ep, fp;
	    fprintf fo, " %o", den;
	end if;
	for j:=1 to #tmp do
	    fprintf fo, " %o", tmp[j];
	end for;
	fprintf fo, "\n";
end procedure;

InspectIdeals := procedure(p, r, Kdata, elt)
	assert(Degree(Kdata) eq 4);
        FpW<W>:=PolynomialRing(GF(p));
	K:=Kdata["K"];
	t:=K.1;
	galac:=Kdata["Galois"];
        id:=ideal<Kdata["OK"] | [p, 0, 0, 0], [p-r, 1, 0, 0]>;
	ok,gen:=IsPrincipal(id);
	printf "gen(%o, %o)=%o\n", p, r, K!gen;
	eltW:=FpW!Eltseq(K!elt);
	for cyc in galac[2] do
	  for sig in cyc do
	    // sigma(r) = e or sigma^(-1)(e) = r
	    eltZ:=PolynomialRing(K)!Eltseq(K!elt);
	    sigt:=&+ [Coefficient(sig,i)*t^i : i in [0..Degree(sig)]];
	    gp:=Evaluate(eltZ, sigt);
	    printf "sig=%o => gp=%o (%o)\n", sig, gp, Norm(gp);
	  end for;
	end for;
end procedure;

// OUTPUT: ok, PZ(r) mod p.
RatEvaluate := function(FpW, PZ, r)
	den:=Lcm([Denominator(Coefficient(PZ, i)) : i in [0..Degree(PZ)]]);
	p:=#BaseRing(FpW);
	if (den mod p) eq 0 then
	    printf "den = 0!!!!\n";;
	    return false, 0;
	end if;
	return true,Evaluate(FpW!Eltseq(PZ), r);
end function;

// INPUT: lp a list of elements in K of norm p; id = [p, alpha-r] an ideal.
// OUTPUT: true/false, a generator for id found using conjugates of elt
// 	   under Galois.
// For this, we use:
// 1. elt*OK=[p, alpha-e] generates id <=> eltW(e) = 0.
// 2. sigma([p, alpha-r]) = [p, alpha-sigma^(-1)(r)].
// So that we want to find sigma s.t. sigma^(-1)(e) = r, in which case
// sigma(elt) will generate id; this test is also e = sigma(r).
FindGeneratorWithGalois := function(p, r, Kdata, lp)
        FpW<W>:=PolynomialRing(GF(p));
	K:=Kdata["K"];
	t:=K.1;
	galac:=Kdata["Galois"];
	for elt in lp do
	    // a priori, elt is in OK
	    eltW:=FpW!Eltseq(K!elt);
	    g:=Gcd(eltW, FpW!Eltseq(DefiningPolynomial(K)));
	    if DLP_DEBUG ge 2 then
	        printf "# Gcd = %o\n", g;
	    end if;
	    if Degree(g) ne 1 then
	        printf "# Gcd = %o mod %o\n", g, p;
		InspectIdeals(p, r, Kdata, elt);
		error("Degree(g) != 1");
		return false, 0;
	    end if;
	    e:=-Coefficient(g, 0);
	    if DLP_DEBUG ge 2 then
	        printf "# root(%o) = %o\n", elt, e;
	    end if;
	    for cyc in galac[2] do
	      for sig in cyc do
	        ok,rr:=RatEvaluate(FpW, sig, r);
		if not ok then return false, 0; end if;
		if DLP_DEBUG ge 2 then
	 	    printf "## (%o)(%o)=%o\n", sig, r, rr;
		end if;
		if rr eq e then
		    // sigma(r) = e or sigma^(-1)(e) = r
		    eltZ:=PolynomialRing(K)!Eltseq(K!elt);
		    sigt:=&+ [Coefficient(sig,i)*t^i : i in [0..Degree(sig)]];
		    gp:=Evaluate(eltZ, sigt);
		    return true, K!Eltseq(gp), sig;
		end if;
	      end for; // for sig
	    end for; // for cyc
	end for;
	error("no generator found");
	return false, 0;
end function;

ReadAlgpr := procedure(~lipr, ~pamax, algpr, f)
	printf "# Reading file %o\n", algpr;
        fd:=POpen("gzip -dc " * algpr, "r");
	lipr:=AssociativeArray();
	npr:=0;
        while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    npr:=npr+1;
	    if npr mod 100000 eq 0 then
	        printf "# reading %o-th ideal at %o\n", npr, Cputime();
	    end if;
	    // s = "i p r"
	    tmp:=Split(s, " ");
	    i:=StringToInteger(tmp[1], 16);
	    p:=StringToInteger(tmp[2], 16);
	    r:=StringToInteger(tmp[3], 16);
	    // patch_begin
//	    if (Integers()!Evaluate(f, r)) mod p ne 0 then continue; end if;
	    // patch_end
	    if IsDefined(lipr, p) then
if false then
	        // patch again_begin
		ok:=true;
		for ir in lipr[p] do
		    if ir[2] eq r then ok:=false; break; end if;
		end for;
		if not ok then continue; end if;
		// patch again_end
end if;
	        lipr[p]:=Append(lipr[p], <i, r>);
	    else
	        lipr[p]:=[<i, r>];
	    end if;
	    pamax:=p;
	end while;
end procedure;

BatchGenerators := procedure(~good, ~bad, generators, Kdata, badp, lipr, ldone, algprimes)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	zero:=[0 : i in [1..Degree(K)-2]];
	imin:=-1;
	imax:=-1;
	tot:=Cputime();
	totmb:=0.0;
	totmin:=0.0;
	npcp:=0;
	ndone:=0;
	npr:=0;
	for p in algprimes do
	  npr:=npr+1;
	  if npr mod 1000 eq 0 then
	        printf "# computing generator for %o-th ideal[%o] at %o\n", 
		       npr, p, Cputime();
	  end if;
	  for ir in lipr[p] do
	    i,r:=Explode(ir);
	    if imin eq -1 or i lt imin then imin:=i; end if;
	    if imax eq -1 or i gt imax then imax:=i; end if;
	    id:=ideal<OK | [p, 0] cat zero, [p-r, 1] cat zero>;
	    if p in badp then
	        printf "bad: id(<%o, %o>) = %o\n", p, r, id;
	        bad[i]:=GeneratorForBad(Kdata, p, id);
	    else
		ok:=false;
		if IsDefined(ldone, p) then
		    tp:=Cputime();
//		    printf "%o: %o\n", lipr[p], #ldone[p];
		    ok,gp:=FindGeneratorWithGalois(p, r, Kdata, ldone[p]);
		    totmb:=totmb+Cputime(tp);
		    if ok then
//		        printf "FG(%o, %o) -> %o (%o)\n", p, r, gp, Norm(gp);
//		    	assert(gp in id);
			tp:=Cputime();
			good[i]:=Minimize(Kdata, K!gp);
			totmin:=totmin+Cputime(tp);
		    else // obsolete or cautious?
		    	error("obsolete?");
		    end if;
//		    if not ok then printf "missed\n"; end if;
//		    printf "# membership: %o %o\n", #l[p], Cputime(tp);
		    ndone:=ndone+1;
		end if;
		if ok then
//		    printf "found: %o\n", good[i][1];
//		    Exclude(~l[p], good[i][1]);
		else // most probably, lp[p] = NULL
		    if DLP_DEBUG ge 2 then
		        printf "I need to principalize: %o %o^%o\n", 
		    	          p, ir, Kdata["hK"];
		    end if;
		    tp:=Cputime();
		    ok,gp,gen,tp2:=GetGeneratorFromScratch(Kdata, id);
		    if not ok then error("Not principal in Gen"); end if;
		    good[i]:=gen;
		    totmin:=totmin+tp2;
		    // trick: add it to lp[]
		    npcp:=npcp+1;
		    ldone[p]:=[K!gp]; // why not gen???
		end if;
	    end if;
//if i gt 20 then error("FFF"); end if;
	  end for;
	end for;
	printf "#T# imin=%o imax=%o totpcp=%o totmb=%o totmin=%o npcp=%o ndone=%o\n", 
	       imin, imax, Cputime(tot), totmb, totmin, npcp, ndone;
	tp:=Cputime();
        fo:=POpen("gzip -c > " * generators, "w");
	// TODO: to be sure, we should print OK and/or the units?
	for i:=imin to imax do
	    if IsDefined(good, i) then
       	        PrintGenerator(fo, i, good[i], false);
	    elif IsDefined(bad, i) then
       	        PrintGenerator(fo, i, bad[i], true);
	    end if;
	end for;
	printf "#T# output: %o\n", Cputime(tp);
end procedure;

// SIDE-EFFECT: fills in GEN with generators of all ideals, good or bad.
GeneratorsForPR := procedure(~GEN,Kdata,badidealinfo,algpr,generators)
	K:=Kdata["K"];
        badid:=ReadBadIdeals(K, badidealinfo);	       
	badp:=[x[1] : x in badid];
	printf "# bad ideals=%o\n", badid;
	// read algpr in a table: useful to have in-core?
	ReadAlgpr(~lipr, ~pamax, algpr, DefiningPolynomial(K));
	printf "# pamax = %o\n", pamax;
	printf "# enumerating at %o\n", Cputime();
	l:=EnumeratePrimeNorms(Kdata, lipr, pamax);
//	printf "K:=%m;\nOK:=MaximalOrder(K);\n", K;
//	print l;
	printf "# inspecting at %o\n", Cputime();
	good:=AssociativeArray();
	bad:=AssociativeArray();
	algprimes:=Sort([x : x in Keys(lipr)]);
	BatchGenerators(~good,~bad,generators,Kdata,badp,lipr,l,algprimes);
	GEN["good"]:=good;
	GEN["bad"]:=bad;
end procedure;

// GEN[i] = x
// BAD[i] = <x, ind, deg>
ReadGeneratorsForPR := procedure(~GEN, K, generators)
	printf "# Reading generators for renumbered ideals from %o\n", 
	       	  generators;
	t:=K.1;
	good:=AssociativeArray();
	bad:=AssociativeArray();
	try
	    fd:=POpen("gzip -dc " * generators, "r");
	catch e
            printf "[%o]\n", e`Object;
            return;
        end try;
	npr:=0;
        while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    npr:=npr+1;
// if npr gt 50 then break; end if; // for fast debug
	    if npr mod 100000 eq 0 then
	        printf "# reading %o-th generator at %o\n", npr, Cputime();
	    end if;
	    // s = "i -ram_ind ram_deg den x0 ... x_{deg-1}"
	    // or
	    // s = "i den x0 ... x_{deg-1}" with den > 0
	    // x_i are rational integers
	    tmp:=Split(s, " ");
	    i:=StringToInteger(tmp[1]);
	    ind:=StringToInteger(tmp[2]);
	    if ind gt 0 then
	        // ordinary case
		den:=ind;
		ind:=1;
		deg:=1;
		j0:=3;
	    else
	        // a bad ideal
		ind:=-ind;
	        deg:=StringToInteger(tmp[3]);
	    	den:=StringToInteger(tmp[4]);
		j0:=5;
	    end if;
	    x:=0;
	    for j:=j0 to #tmp do
	        x:=x + StringToInteger(tmp[j]) * t^(j-j0);
	    end for;
	    // GEN[i], BAD[i] = <elt_of_K, ...>
	    if j0 eq 3 then
	        good[i]:=x/den;
		if DLP_DEBUG ge 2 then
	  	    printf "good[%o]=%o (%o)\n", i, good[i], Norm(good[i]);
		end if;
	    else
		bad[i]:=<x/den, ind, deg>;
	    	printf "bad[%o]=%o (%o)\n", i, bad[i], Norm(bad[i][1]);
	    end if;
	end while;
	GEN["good"]:=good;
	GEN["bad"]:=bad;
end procedure;

// now read all ab pairs from purged, together with the ideal numbers
// eps[(a, b)_i] <- unit for (a-b*theta) given its algebraic factorization.
// All that matters is that index i.
UnitsForPurged := procedure(~epsab,Kdata,GEN,purged)
	tp:=Cputime();
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	U:=Kdata["UK"];
	t:=K.1;
	good:=GEN["good"];
	bad:=GEN["bad"];
        fd:=POpen("gzip -dc " * purged, "r");
	s:=Gets(fd);
	// read first line: s = "# 10807 37271 10805"
	tmp:=Split(s, " ");
	nr:=StringToInteger(tmp[2]);
	lc:=StringToInteger(tmp[3]);
	nc:=StringToInteger(tmp[4]);
	printf "# nr = %o, lc = %o, nc = %o\n", nr, lc, nc;
	iab:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "-ad21b,8217:4,6,6,c,18,166,1c9,5f4,ad3,1fbc,14,8e,7e7,e23,8d73,0"
	    tmp:=Split(s, ":");
	    tmp2:=Split(tmp[1], ",");
	    a:=StringToInteger(tmp2[1], 16);
	    b:=StringToInteger(tmp2[2], 16);
//	    printf "# s = %o\n", s;
	    if DLP_DEBUG ge 2 then
	        printf "a:=%o; b:=%o;\n", a, b;
//	        printf "a-b*m=%o\n", Factorization(Integers()!(a-b*m));
	    	printf "Norm(a-b*t)=%o\n", Factorization(Integers()!Norm(a-b*t));
		printf "lf = %o\n", Factorization((a-b*t)*OK);
	    end if;
	    tmp2:=Split(tmp[2], ",");
	    // among these, we have rational or algebraic primes
	    li:=[];
	    oldi:=-1;
	    exi:=1;
	    for stri in tmp2 do
	    	i:=StringToInteger(stri, 16);
                sgn := 1;
                if i lt 0 then
                    i := -i;
                    sgn := -1;
                end if;
	        if not IsDefined(good, i) and not IsDefined(bad, i) then
		    continue;
		end if;
		if i eq oldi then
		    exi:=exi+sgn;
		elif oldi ne -1 then
		    li[#li+1]:=<oldi, exi>;
		    exi:=sgn;
                else
                    exi:=sgn;
		end if;
		oldi:=i;
	    end for;
	    if oldi ne -1 then
	        li[#li+1]:=<oldi, exi>;
	    end if;
	    prod:=1;
	    for iexi in li do
	        i,exi:=Explode(iexi);
		if IsDefined(good, i) then
		    if DLP_DEBUG ge 2 then
		        printf "multiplying by good[%o]^e=%o^%o",i,good[i],exi;
		        printf " of norm %o\n", Norm(good[i]);
		    end if;
                    gg := good[i];
                    if exi lt 0 then
                        // Replace gg by its conjugate
                        gg := Evaluate(Polynomial(Eltseq(gg)), 1/t);
                        exi := -exi;
                    end if;
		    prod:=prod * gg^exi;
		elif IsDefined(bad, i) then
                    assert exi gt 0;
		    if DLP_DEBUG ge 2 then
		        printf "multiplying by bad[%o]^e=%o^%o", 
			       i, bad[i][1], exi div bad[i][3];
		        printf " of norm %o\n", Norm(bad[i][1]);
		    end if;
		    prod:=prod * bad[i][1]^(exi div bad[i][3]);
		end if;
	    end for;
	    eta:=((a-b*t)^Kdata["hK"])/prod;
	    if DLP_DEBUG ge 2 then
	        printf "eta=%o => Norm=%o\n", eta, Norm(eta);
	    end if;
	    iab:=iab+1;
	    epsab[iab]:=RecoverUnits(Kdata, OK!eta);
	    if epsab[iab] eq [] then error("No unit found"); end if;
	end while;
	printf "#T# units for purged relations: %o\n", Cputime(tp);
end procedure;

// File XXX.index
// ==============
// 
// Is is created by replay, and contains the link between the rows of the
// small matrix (coming out from merge/replay) and the relation sets to
// which they correspond.
// 
// The first line gives number of rows (relation-sets) and columns (ideals)
// after the merge/replay.
// 
// Then, each line of the file corresponds to a line of the small matrix:
// the first entry is an integer giving the number of relations in the
// relation-set, and the rest of the line gives the indices of the relations
// (in hexadecimal). These indices relate to the numbers of the lines in the
// purged.gz file.
// 
// For DL, each entry is of the form id:e, where id is the index in the
// purged.gz file, and e is the exponent of the corresponding relation in
// the relation-set.
DLProduceUnits := procedure(~mat, purged, index, rK, FB, epsab)
	ab:=DLReadPurged(purged);
        fd:=POpen("gzip -dc " * index, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	small_ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, small_ncols;
	i:=0;
	eps:=[0] cat [0 : j in [1..rK]];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "3 2c:-1 98:1 a7b:1"
	    tmp:=Split(s, " ");
	    nab:=StringToInteger(tmp[1]);
	    i:=i+1;
	    if i mod 10000 eq 0 then
	        printf "## relation-set %o at %o\n", i, Cputime();
	    end if;
	    for	u:=1 to rK+1 do eps[u]:=0; end for;
	    for k:=1 to nab do
	        // tmp[k+1] = "2c:-1"
		foo:=Split(tmp[k+1], ":");
		id:=1 + StringToInteger(foo[1], 16);
		e :=StringToInteger(foo[2]);
		if ab[id][2] eq 0 then
		    // free relation
		    eta:=FB[ab[id][1]][2];
		    if DLP_DEBUG ge 2 then
		        printf "freerel: %o^e=%o^%o\n", ab[id], eta, e;
		    end if;
		else
		    eta:=epsab[ab[id]];
		    if DLP_DEBUG ge 2 then
		        printf "%o^e=%o^%o\n", ab[id], eta, e;
		    end if;
		end if;
		// update units
		for u:=1 to #eta do
		    eps[u]:=eps[u] + e * eta[u];
		end for;
	    end for;
	    if DLP_DEBUG ge 2 then
	        printf "eps(R%o)=%o\n", i, eps;
	    end if;
	    // we don't care about the sign of eps...
	    mat[i]:=eps[2..rK+1];
	end while;
end procedure;

// epsab[i] = unit for (a, b)_i for i in index.
DLProduceUnits2 := procedure(~mat, index, rK, epsab)
        fd:=POpen("gzip -dc " * index, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	small_ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, small_ncols;
	i:=0;
	eps:=[0] cat [0 : j in [1..rK]]; // FIXME
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "3 2c:-1 98:1 a7b:1"
	    tmp:=Split(s, " ");
	    nab:=StringToInteger(tmp[1]);
	    i:=i+1;
	    if i mod 10000 eq 0 then
	        printf "## relation-set %o at %o\n", i, Cputime();
	    end if;
	    for	u:=1 to rK+1 do eps[u]:=0; end for; // FIXME
	    for k:=1 to nab do
	        // tmp[k+1] = "2c:-1"
		foo:=Split(tmp[k+1], ":");
		id:=1 + StringToInteger(foo[1], 16);
		e :=StringToInteger(foo[2]);
		eta:=epsab[id];
		// update units
		for u:=1 to #eta do
		    eps[u]:=eps[u] + e * eta[u];
		end for;
	    end for;
	    if DLP_DEBUG ge 2 then
	        printf "eps(R%o)=%o\n", i, eps;
	    end if;
	    // we don't care about the sign of eps...
	    mat[i]:=eps[2..rK+1];
	end while;
end procedure;

// read from .poly
ReadDataFromPolyFile := procedure(~params, name)
	fd:=Open(name, "r");
	f:=0;
	g:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    tmp:=Split(s, " ");
	    if #tmp eq 2 then
	        if tmp[1] eq "n:" then
	            p:=StringToInteger(tmp[2]);
		elif tmp[1][1] eq "c" then
		    // tmp[1] = "c0:"
		    i:=StringToInteger(tmp[1][2]); // humf!
		    f:=f+StringToInteger(tmp[2]) * X^i;
		elif tmp[1][1] eq "Y" then
		    // tmp[1] = "Y0:"
		    i:=StringToInteger(tmp[1][2]); // humf!
		    g:=g+StringToInteger(tmp[2]) * X^i;
		end if;
	    end if;
	end while;
	FpW:=PolynomialRing(GF(p));
	varphi:=Gcd(FpW!Eltseq(f), FpW!Eltseq(g));
	printf "# gcd = %o\n", varphi;
	params["p"]:=p;
	params["f"]:=f;
	params["g"]:=g;
	params["varphi"]:=varphi;
end procedure;

// REM: this might change with future cleaning.
DumpParamsFile := procedure(~params, ficparams)
        fd:=Open(ficparams, "r");
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    tmp:=Split(s, " ");
	    if tmp eq [] then continue; end if;
	    if tmp[1] eq "gorder" then
	        // s = "gorder = 52879981773903133"
		params["ell"]:=StringToInteger(tmp[3]);
	    elif tmp[1] eq "rlim" then
	        params["lim0"]:=StringToInteger(tmp[3]);
	    elif tmp[1] eq "alim" then
	        params["lim1"]:=StringToInteger(tmp[3]);
	    end if;
	end while;
end procedure;

// Useful for verification.
DLReadSmallMatrix := function(small, extra, ell)
        fd:=Open(small, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, ncols;
	Fell:=GF(ell);
	M:=SparseMatrix(Fell, nrows, ncols+extra);
	i:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "16 2:1 0:1 3:1 4:2 7:1 18:1 36:1 8...."
	    // fill in row_i
	    i:=i+1;
	    tmp:=Split(s, " ");
	    nk:=StringToInteger(tmp[1]);
	    for k:=1 to nk do
	        // tmp[k+1] = "2:1"
		foo:=Split(tmp[k+1], ":");
		j:=1 + StringToInteger(foo[1]);
		M[i, j]:=Fell ! StringToInteger(foo[2]);
	    end for;
	end while;
	return M;
end function;

// Used for verification only.
DLReadSM := procedure(~M, sm, rK)
        fd:=Open(sm, "r");
	// read first line: small_nrows
	s:=Gets(fd);
	nr:=StringToInteger(s);
	assert(nr eq NumberOfRows(M));
	ncols:=NumberOfColumns(M);
	Fell:=Parent(M[1, 1]);
	i:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "26476811979143817355732776187682666169 5914672..."
	    i:=i+1;
	    tmp:=Split(s, " ");
	    for k:=1 to rK do
	        M[i, ncols-rK+k]:=StringToInteger(tmp[k]);
	    end for;
	end while;	
end procedure;

// OUTPUT: if generate then FB,epsab,G,GEN;
UnitsWithParams := function(Kdata, FB, epsab, GEN, generate, params)
//	p,f,g,varphi:=ReadDataFromPolyFile(params["poly"]);
        if DLP_VERIFICATION then
	    ell:=params["ell"];
	end if;
	if generate then
	    FB:=AssociativeArray();
	    GEN:=AssociativeArray();
	end if;
//	K<t>:=ext<QQ | f>; // FIXME
	K:=ext<QQ | params["f"]>; // FIXME
	Kdata:=PrepareField(K, true); // FIXME
	rK:=Kdata["rK"];
        if DLP_VERIFICATION then
	    printf "# Reading small matrix\n";
	    small:=params["small"];
	    mat:=DLReadSmallMatrix(small, rK, ell);
	    printf "# Glue-ing sm matrix\n";
	    DLReadSM(~mat, params["sm"], rK);
	    ncols:=NumberOfColumns(mat);
	    printf "# Now computing kernel of %o x %o for debug/fun\n",ncols,ncols;
	    return NullspaceOfTransposeMatrix(ExtractBlock(mat,1,1,ncols,ncols));
 	end if;
// OBSOLETE
        // space for rK units (we don't care about signs...!)
//	mat:=DLReadSmallMatrix(small, rK, ell);
//      fb:=params["fb"];
//	if generate then // humf!
//	    ReadFactorBase(~FB, K, OK, U, fb, Degree(f));
//	end if;

        purged:=params["purged"];
	if generate then
	    BAD:=AssociativeArray();
	    epsab:=AssociativeArray();
	    if IsDefined(params, "relsdir") then
	        error("Correct this!!!!!");
//	    	TreatFromDir(~FB,~epsab,p,f,g,Kdata,params["relsdir"]);
	    elif IsDefined(params, "algpr") then
	        GeneratorsForPR(~GEN,Kdata,params["badidealinfo"],
				params["algpr"],params["generators"]);
		UnitsForPurged(~epsab,Kdata,~GEN,purged);
	    end if;
	    return FB,epsab,GEN,Kdata; // OHHHHHHHHHHHHHHHH!
	else
	    printf "# epsab already computed\n";
	end if;

	U:=Kdata["UK"];
	tp:=Cputime();
	index :=params["index"];
	mat:=[];
	if IsDefined(params, "relsdir") then
 	    DLProduceUnits(~mat, purged, index, #U["units"], FB, epsab);
	else
 	    DLProduceUnits2(~mat, index, #U["units"], epsab);
	end if;
	printf "#T# producing units: %o\n", Cputime(tp);
	nrows:=#mat;
	// last two cols should be plenty of eps values...!
	ficunits:=params["ficunits"];
	printf "## outputting units to file %o\n", ficunits;
	fd:=Open(ficunits, "w");
	fprintf fd, "%o\n", nrows;
	for i:=1 to nrows do
	    // only rK components, we don't care about the sign!
	    for j:=1 to rK do
	        fprintf fd, "%o", mat[i][j];
		if j lt rK then fprintf fd, " "; end if;
	    end for;
	    fprintf fd, "\n";
	end for;
        return [];
end function;

// ell:=63682780151674075656521332710720136307;
// Kdata,FB,epsab,G:=UnitsFromCADO("SNFS", "p59", ell, [], [], [], [], true);
// UnitsFromCADO("SNFS", "p59", ell, Kdata, FB, epsab, G, false);
UnitsFromCADO := function(dir, name, ell, Kdata, FB, epsab, G, GEN, BAD, gen_epsab)
        params:=AssociativeArray();
	if DLP_VERIFICATION then
	    params["ell"]:=ell;
	    params["small"]:=dir * "/" * name * ".merge.small.txt";
	    params["sm"]:=dir * "/" * name * ".sm.sm";
	end if;
        // "p59"  ===> "SNFS/p59/"
	dir:=dir * "/" * name;
	params["poly"]:=dir * "/" * name * ".polyselect2.poly";

	// not needed, actually
	// fb = "SNFS/p59/p59.factorbase.roots"
	// params["fb"]:=dir * "/" * name * ".factorbase.roots.gz";

        // "p59"  ===> "SNFS/p59/p59.upload/p59"
// 	params["relsdir"]:=dir * "/" * name * ".upload/" * name;
	params["renumber"]:=dir * "/" * name * ".freerel.renumber.gz";
	params["algpr"]:=dir * "/" * name * ".algpr.gz";
	params["generators"]:=dir * "/" * name * ".generators.gz";
	params["purged"]:=dir * "/" * name * ".purge.purged.gz";
	params["index"]:=dir * "/" * name * ".merge.index.gz";
	params["ficunits"]:=dir * "/" * name * ".units.units";
	return UnitsWithParams(Kdata, FB, epsab, GEN, gen_epsab, params);
end function;

// ComputeUnits("SNFS", "p59", 63682780151674075656521332710720136307);
// ComputeUnits("SNFS", "p60-2", 13);
// ComputeUnits("SNFS", "p65d5", 13);
ComputeUnits := procedure(dir, name, ell)
	Kdata,FB,epsab,G,GEN,BAD:=
		UnitsFromCADO(dir,name,ell,[],[],[],[],[],[],true);
	UnitsFromCADO(dir, name, ell, Kdata, FB, epsab, G, GEN, BAD, false);
end procedure;

// If generate = true, we must build algpr and generators.
ComputeUnitsFromWrapper := procedure(polyfile,renumber,algpr,generators,badidealinfo,purged,index,ficunits,generate)
        params:=AssociativeArray();

	params["poly"]:=polyfile;

// 	params["relsdir"]:=relsdir;
	params["renumber"]:=renumber;
	params["algpr"]:=algpr;
	params["generators"]:=generators;
	params["badidealinfo"]:=badidealinfo;

	params["purged"]:=purged;
	params["index"]:=index;
	params["ficunits"]:=ficunits;

	FB:=[];
	GEN:=AssociativeArray();
	ReadDataFromPolyFile(~params, params["poly"]);
	f:=params["f"];
	K:=ext<QQ | f>;
	Kdata:=PrepareField(K, true); // FIXME
	if generate then
	    GeneratorsForPR(~GEN,Kdata,params["badidealinfo"],
			    params["algpr"],params["generators"]);
	else
	    ReadGeneratorsForPR(~GEN, K, generators);
	    epsab:=AssociativeArray();
	    UnitsForPurged(~epsab,Kdata,GEN,purged);
	    UnitsWithParams(Kdata, FB, epsab, GEN, false, params);
	end if;
end procedure;

// Simul("SNFS", "p59", true); // ===> "SNFS/p59"
// Simul("GFP2", "p2dd30", true);
// Simul("GFP2", "p277", true);
// Simul("../catrel/GFP3", "p3dd10", true);
Simul := procedure(dir, name, gen)
	dir:=dir * "/" * name;
	poly:=dir * "/" * name * ".polyselect2.poly";
	renumber:=dir * "/" * name * ".freerel.renumber.gz";
	algpr:=dir * "/" * name * ".algpr.gz";
	generators:=dir * "/" * name * ".generators.gz";
	purged:=dir * "/" * name * ".purge.purged.gz";
	index:=dir * "/" * name * ".merge.index.gz";
	ficunits:=dir * "/" * name * ".units.units";
	bad:=dir * "/" * name * ".magmanmbrthry.badidealinfo";

	// FIXME: strange what happens here -> simplify?
	if gen then
	    printf "# computing generators\n";
	    ComputeUnitsFromWrapper(poly,renumber,algpr,generators,bad,
				    purged,index,ficunits,true);
//error("p277");
	end if;
	printf "# computing units for file %o\n", purged;
	ComputeUnitsFromWrapper(poly,renumber,algpr,generators,bad,
				purged,index,ficunits,false);
end procedure;

print "Simul(\"../catrel/GFP3\", \"p3dd10\", true);";
// Simul("SNFS", "p60x4x4", false);

// units = non-torsion units.
CheckUnitsAux := function(K, units)
	Kdata:=PrepareField(K, true);
	logu:=[AllEmbeddings(Kdata, K!units[i]) : i in [1..#units]];
	M:=KMatrixSpace(R20, #units, #units+1)!logu;
//	print M;
	printf "rank(M)=%o\n", Rank(M);
	return M;
end function;

// We want to solve eps^P(sigma) = eps0.
// Typical example: eps^{1+sigma^2} = eps0.
// Write eps = prod units[i]^a[i].
// All eps are in K.
UnitPolyEq := function(Kdata, Psig, eps0)
      U:=Kdata["UK"];
      rK:=Kdata["rK"];
      units:=U["units"];
      y:=U["logunits"];
      leps0:=AllEmbeddings(Kdata, eps0);
      print eps0, leps0;
      // TODO: apply Psig here!!!
      l:=[AllEmbeddings(Kdata, units[i]) : i in [1..#units]];
      M:=KMatrixSpace(R20, rK+1, rK+1)!l;
      print M;
      print Rank(M);
      print IsConsistent(M, leps0);
error("FF");
      // we want to solve M.V = leps0
      return true;
end function;

// From Gras79: K cyclic quartic
// G = <sigma>, k quadratic subfield of K
// E_K = unit group of K
// chi relative unit iff chi^(1+sigma^2) = +/- 1
Gras4 := procedure(K, units)
      	Kdata:=PrepareField(K, true);
	 // TODO: match units with units...!
	r:=K.1;
        K2:=Subfields(K, 2);
	K2,map:=Explode(K2[1]);
	printf "K2=%o; map=%o;\n", K2, map;
	unitsK2,map2:=UnitGroup(K2);
	eps0:=K2!map2(unitsK2.2);
	printf "UK2=%o: eps0=%o -> %o\n", unitsK2, eps0, map(eps0);
	printf "r^(1+sigma^2)=%o\n", r*units[3]; // r^(1+sigma^2);
//	printf "r2^(1+sigma^2)=%o\n", units[2]*r4; // r2^(1+sigma^2);
	// = -1, hence r is a relative unit
	// E_chi = <eps_chi>, u_chi = \pm eps_chi^{mu+nu*sigma}
	// E_k unit group of k
	// E^K = E_k + E_chi, E_k = <eps_0>
	// Q_K = (|E_K|:|E^K|) = 1 or 2 by Hasse;
	// Q_K = 2 <=> there exists a Minkowski unit eps
	//         <=> exists u in E_K s.t. u^{1+sigma^2} = +/- eps_0
	//             [as a matter of fact, u = eps]
	// Minkowski unit: eps and some of its conjugates form a system
	// of fundamental units
//	KK<[a]>:=PolynomialRing(K, 4);
//	u:=&+ [ a[i+1] * r^i : i in [0..3] ];
//	u2:=&+ [ a[i+1] * units[3]^i : i in [0..3] ];
//	print u*u2-map(eps0);
	UnitPolyEq(Kdata, 1+X^2, map(eps0));
end procedure;

CheckUnits := function(d, A)
	 if d eq 3 then
	    // from Foster12
	    K<r>:=ext<QQ | X^3-A*X^2-(A+3)*X-1>;
	    // r = X and its conjugates are units
	    // sigma:=(-r-1)/r; sigma2:=-1/(r+1); sigma3:=r;
	    // eps1 = r, eps2 = -(1+1/r) = -r^2+r+3
	    // eps3 = 1/(eps1*eps2) -- of course
	    // g2 = r+1 = eps1+1 = -eps1*eps2
	    // g3 = -r^2+2*r+1 = 1/eps2
	    // => {eps1, eps2} system of fundamental units
	    // sigma(eps1) = eps2
	    // sigma(eps2) = eps3 = 1/(eps1*eps2)
	    // log(sigma(eps1)) = p*log(eps1) = log(eps2)
	    // but p = -1 mod ell => log(eps2) = -log(eps1)
	    // log(sigma(eps2)) = p*log(eps2) = -log(eps1)-log(eps2)
	    // or -log(eps2) = -log(eps1)-log(eps2)
	    // => log(eps1) = log(eps2) = 0
	    units:=[];
	    units[1]:=r;
	    for i:=2 to 2 do
	    	units[i]:=(-units[i-1]-1)/units[i-1];
	    end for;
	 elif d eq 4 then
            K<w>:=ext<QQ | X^4-A*X^3-6*X^2+A*X+1>;
	    units:=[];
	    // w -> w2 = sigma(w) -> w3 = sigma^2(w) -> w4 = 1/w/w2/w3
	    units[1]:=w;
	    for i:=2 to 3 do
	    	units[i]:=(units[i-1]-1)/(units[i-1]+1);
	    end for;
	    w4:=1/(units[1]*units[2]*units[3]);
	    printf "<w>=%o, %o\n", units, w4;
	    // w is a chi-relative unit of norm -1 over k
	    // k = K^<sigma^2> = K_2
	    // K has conductor f, k has conductor m, f = m*g
	    // (t, z, x, y), r = -6 <=> t^2+16 = m*z^2 or z^2=g*(x^2+y^2)
	    // v2(m) = 0 or 3
	    // m = a^2+b^2 has a finite number of solutions
	    // z^2 = g*(x^2+y^2)
	    // t*z = g*(a*(x^2-y^2)-2*b*x*y)
	    // t^2+m*z^2 = -16+2*f*(x^2+y^2)
	    //
	    // when t=1, one has 17=17*1^2, m = 1^2+4^2
	    // 1 = g*(x^2+y^2) => g = 1, x = 0 or y = 0
	    // t*z = g*(a*(x^2-y^2)-2*b*x*y)
	    // 1+17 = -16+2*f => f = 17 => Q_K = 2
	    //
	    // It is not true that Q_K = 2 for the whole family...
	    //
	    // if t <= f/2-4, then E_chi = <w>, which is the case for t=1
	    //
	    // Y = Z-1/Z => Z^2-Y*Z-1 = 0, disc = Y^2+4 > 0
	    //
	 end if;
	 print units;
	 Gras4(K, units);
	 return CheckUnitsAux(K, units);
end function;

TryRankAux := function(K)
	Kdata:=PrepareField(K, true);
	OK:=Kdata["OK"];
	galac:=Kdata["Galois"];
	UK:=Kdata["UK"];
	// UK = { grouptable, Minv, logunits, units, rK }
	units:=UK["units"];
	G:=UK["grouptable"];
	for i:=1 to #units do
	    eps:=K!units[i];
	    printf "\neps[%o]=%o\n", i, eps;
	    for cyc in galac[2] do
	    	for sig in cyc do
		    eta:=Evaluate(sig, eps);
		    if Abs(Norm(eta)) eq 1 then
	    	        printf "sigma:=%o;\n", sig;
	    	    	printf "eta:=%o; Norm:=%o;\n", eta, Norm(eta);
			print RecoverUnits(Kdata, OK!eta);
		    end if;
		end for;
	    end for;
	end for;
	return Kdata;
end function;

TryRank := function(d, A)
	if d eq 3 then
	    K:=ext<QQ | X^3-A*X^2-(A+3)*X-1>;
	elif d eq 4 then
            K:=ext<QQ | X^4-A*X^3-6*X^2+A*X+1>;
	    // sigma(r):=(-r-1)/(r-1);
	    // r2:=sigma(r);
	    // r3:=sigma(r2);
	    // r4:=sigma(r3)=1/(r1*r2*r3)
	end if;
	return TryRankAux(K);
end function;

// for d = 3, t0 = 1 (and more?)
// TODO: recover formula for the units in a canonical way and compute
// action of sigma, also in a canonical form.
// alpha is a unit.
//
// sigma(alpha) = -1/(alpha+1)?????
// (alpha+1)*(alpha^2-(a+1)*alpha-2) = -1
//
// eps_1 = alpha+1
// eps_2 = -alpha^2+1
// sigma:=-Z^2 - Z + 1;
// sigma(eps_1) = eps_1^3*eps_2
// sigma(eps_2) = -eps_1*eps_2 = eps_1-1
// does it help?
// log(sigma(eps_1)) = p*log(eps_1) = 3*log(eps_1)+log(eps_2)
// log(sigma(eps_2)) = p*log(eps_2) = log(eps_1)+log(eps_2)
// or (p-3)*log(eps_1) - log(eps_2) = 0
//    log(eps_1) - (p-2)*log(eps_2) = 0
// and det = -(p-3)(p-2)+1 = - (-4)(-3)+1 <> 0 mod p => log(eps_1)=log(eps_2)=0

PGEX := procedure()
        f:=X^4-35*X^3-48*X^2-35*X+1;
	// On a K = Q/f, K2 = l'unique sous-corps quad de K:
	K<t>:=ext<QQ | f>; // signature (2, 1) => r_K = 2
	// UK is generated by
	eps1:=-t^3 + 35*t^2 + 48*t + 35;
	eps2:=-8*t^3 + 280*t^2 + 392*t + 291;

	K2:=Subfields(K,2);
	K2,m2K:=Explode(K2[1]); // m2K envoie K2 dans K
	UK2,map2K2:=UnitGroup(K2); // map2K2 envoie UK2 dans K2
	eps0:=K2!map2K2(UK2.2); // unite fdale de K2
	// go up to K
	Keps0:=m2K(eps0);
	// -> Keps0 = 8*t^3 - 280*t^2 - 392*t + 11
	// and this Razvan's unit:
	u:=-8*t^3 + 280*t^2 + 392*t + 291;
	// et miracle : u = eps2 = 1/Keps0!!!
	printf "u=%o\n1/u=%o\neps0=%o\n", u, 1/u, Keps0;
end procedure;

ComputeUnitsFromWrapper(polyfile,renumber,algpr,generators,badidealinfo,purged,index,ficunits,ww eq "true"); // don't ask why we should write this...!
exit;
