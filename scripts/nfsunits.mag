/*
Wrapper version, to be used with
  magma -b polyfile:=$POLY renumber:=$RENUMBER algpr:=$ALGPR generators:=$GENERATORS badideals:=BADIDEALS purged:=$PURGED relsdel:=$RELSDEL index:=$INDEX ficunits:=$FICUNITS abunits:=$ABUNITS usef:=true/false ww:=true/false $DIR/nfsunits.mag
*/

//
// author: morain@lix.polytechnique.fr 
//
// Using units in (S)NFS-DL

NFSUNITS_VERSION:="20140321.2045"; // first trial with h > 1
NFSUNITS_VERSION:="20140324.1745"; // Minimize works now for all rK
NFSUNITS_VERSION:="20140327.0730"; // more cleaning w.r.t. U
NFSUNITS_VERSION:="20140329.1930"; // computing m + other stuff
NFSUNITS_VERSION:="20140402.1830"; // ready for GF(p^2)
NFSUNITS_VERSION:="20140402.2100"; // patching while waiting for Cyril
NFSUNITS_VERSION:="20140403.1830"; // after Cyril's modifs
NFSUNITS_VERSION:="20140410.1645"; // ready to shoot
NFSUNITS_VERSION:="20140702.1830"; // degree 6, etc.
NFSUNITS_VERSION:="20140813.1030"; // Minkowski units for deg4
NFSUNITS_VERSION:="20140813.1730"; // some cleaning
NFSUNITS_VERSION:="20140826.1830"; // precision pbs again
NFSUNITS_VERSION:="20140828.1550"; // cleaning potential unit bugs
NFSUNITS_VERSION:="20140828.1840"; // making code work for non-Galois groups
NFSUNITS_VERSION:="20140829.1030"; // bug found
NFSUNITS_VERSION:="20141008.1030"; // symmetrization, etc.

printf "## NFSUNITS_VERSION %o\n", NFSUNITS_VERSION;

QQ:=Rationals();
QX<X>:=PolynomialRing(QQ);
QXT<T>:=PolynomialRing(QX);

// load "cyclicpoly.mag";

DLP_USE_UNITS_FLOAT:=true;
Rsmall:=RealField(40);
Csmall:=ComplexField(Rsmall);
RR:=RealField(80);
RRY<Y>:=PolynomialRing(RR);
CC:=ComplexField(RR);
CCZ<Z>:=PolynomialRing(CC);

DLP_DEBUG:=1;
DLP_VERIFICATION:=false; // for expert debug mode only...

SetColumns(0);

// precompute all products of units^ex with |ex| <= bound.
// Have it deterministic, please.
BuildGroupTable := function(units, bounds)
        if DLP_DEBUG ge 2 then
	    printf "# BSGT --> %o at %o\n", units, Cputime();
	end if;
	G:=AssociativeArray();
	if #units eq 1 then
	    for i:=-bounds[1] to bounds[1] do
	        G[units[1]^i]:=[i];
	    end for;
	else
	    GG:=$$(units[1..#units-1], bounds);
	    for i:=-bounds[#units] to bounds[#units] do
	        prod:=units[#units]^i;
		keys:=Sort([x : x in Keys(GG)]);
		for pr in keys do
		    ind:=prod * pr;
		    G[ind]:=GG[pr] cat [i];
//		    printf "%o => %o\n", ind, G[ind];
		end for;
	    end for;
	end if;
	if DLP_DEBUG ge 2 then
 	    printf "# <-- BSGT %o at %o\n", units, Cputime();
	end if;
	return G;
end function;

// x in K, so a poly in t -> real poly.
AlgToReal := function(x)
        return RRY ! [ RR ! y : y in Eltseq(x)];
end function;

// x in K, so a poly in t -> real poly.
AlgToComplex := function(x)
        return CCZ ! [ CC ! y : y in Eltseq(x)];
end function;

// For elt in K.
AllEmbeddings := function(Kdata, x)
	K:=Kdata["K"];
	roots:=Kdata["roots"];
	r1,r2:=Signature(K);
    	rx:=AlgToComplex(x);
	lemb:=[];
	for i:=1 to r1 do
	    Append(~lemb, Log(Abs(Evaluate(rx, RR!roots[i]))));
	end for;
	for i:=1 to 2*r2 do
	    Append(~lemb, Log(Abs(Evaluate(rx, roots[r1+i]))));
	end for;
	return lemb;
end function;

// basis = {omega_i}, dual = {omega_i^*}.
ComputeDualBasis := function(K, OK)
	n:=Degree(K);
	T:=KMatrixSpace(QQ, n, n)!0;
        for i:=1 to n do
	    for j:=1 to n do
	        T[i, j]:=Trace(OK.i * OK.j);
	    end for;
	end for;
//	printf "# T=\n%o\n", T;
	return T^(-1);
end function;

// OUTPUT: bounds for alpha in OK, |Norm(alpha)| <= B.
// Based on FiPo + BoCh, with more care.
// TODO: better?
FiPoBounds := function(B, Kdata, logunits)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	n:=Degree(K);
if false then
	// compute FiPo bounds
        U:=[];
	for i:=1 to n do
	    U[i]:=&+ [Abs(logunits[j][i]) : j in [1..#logunits]];
	    U[i]:=Exp((Log(B)/n) + 0.5 * U[i]);
	end for;
	printf "# FiPo.U = %o\n", U;
	// use dual basis
	D:=ComputeDualBasis(K, OK);
//	printf "# dual basis:\n%o\n", D;
	// use embeddings to get a bound on |sigma_i(omega_j^*)|
	bounds:=[];
	for j:=1 to n do
	    // omega_j^* = j-th column of D
	    ojs:=&+ [ OK.i * D[i, j] : i in [1..n]];
	    alljs:=AllEmbeddings(Kdata, K!ojs);
//	    printf "# omega_%o^*: %o\n", j, alljs;
	    bounds[j]:=Truncate(&+ [U[i] * Abs(alljs[i]) : i in [1..n]]);
	end for;
	printf "# bounds found: %o\n", bounds;
//	return bounds;
end if;
	if n eq 3 then
//	    return [125 : i in [1..n]];
	    return [20 : i in [1..n]];
	elif n eq 4 then
	    return [20 : i in [1..n]];
	elif n eq 5 then
	    return [20 : i in [1..n]];
	elif n eq 6 then
//	    return [10 : i in [1..n]];
	    return [3 : i in [1..n]];
	else
	    return [20 : i in [1..n]];
	end if;
end function;

// Use LLL? Obsolete?
MinimizeTry := function(Kdata, x, lx)
	rK:=Kdata["rK"];
	U:=Kdata["UK"];
	nU:=#U["logunits"];
	n:=Degree(Kdata["K"]);
	M:=KMatrixSpace(Rsmall, n, nU)!0;
	for i:=1 to n do M[i, 1]:=lx[i]; end for;
	for j:=1 to nU do
	    for i:=1 to n do
	        M[i, j+1]:=U["logunits"][j][i];
	    end for;
	end for;
//	print M;
	Mred,T,rg:=LLL(M);
	// Mred = T * M, T unimodular
	// col 1 of T is [t11 t21 ... tr1]
	// x^t11*eps1^t21*...*epsr^tr1
	printf "T=\n%o\n", T;
	xx:=&* [U["units"][i]^T[1, i+1] : i in [1..nU]];
	if T[1, 1] eq 1 then
	    xx:=x*xx;
	elif T[1, 1] eq -1 then
	    xx:=xx/x;
	else error("Not possible");
	end if;
	printf "xx=%o\n", xx;
end function;

// Any rK.
Minimize := function(Kdata, x)
return x;
	lx:=AllEmbeddings(Kdata, Kdata["K"]!x);
	U:=Kdata["UK"];
	rK:=Kdata["rK"];
	n:=Degree(Kdata["K"]);
	units:=U["units"];
	y:=U["logunits"];
	Rr<[a]>:=PolynomialRing(RR, rK);
	f:=&+ [ (lx[i]- (&+ [a[j]*y[j, i] : j in [1..rK]]))^2 : i in [1..n]];
	df:=[Derivative(f, i) : i in [1..rK]];
//	printf "f:=%o;\n", f;
//	printf "df = %o\n", df;
	M:=KMatrixSpace(Rsmall, rK, rK)!0;
	for i:=1 to rK do
	    for j:=1 to rK do
	        M[i, j]:=Coefficient(df[i], a[j], 1);
	    end for;
	end for;
//	print M;
	invM:=M^(-1);
	c:=[];
	for i:=1 to rK do
	    tmp:=df[i];
	    for j:=1 to rK do
	        tmp:=Coefficient(tmp, a[j], 0);
	    end for;
	    c[i]:=RR!tmp;
	end for;
	amin:=[- (&+ [ invM[i, j] * c[j] : j in [1..rK]]) : i in [1..rK]];
//	printf "amin:=%o;\n", amin;
//	printf "f(min)=%o\n", Evaluate(f, amin);
//	printf "f(min)=%o\n", Evaluate(f, [Round(a1min), Round(a2min)]);
//	printf "f(min)=%o\n", Evaluate(f, [Truncate(a1min), Truncate(a2min)]);
//	error("DD");
	amin:=[Round(amin[i]) : i in [1..rK]];
//	printf "amin = %o\n", amin;
	u:=&* [ units[i]^amin[i] : i in [1..rK] ];
        return x/u;
end function;

// If K is Galois, only one generator has to be stored and the other
// deduced via Galois action; and the first one is enough, no division...
// TODO: use pmax??
InsertInBox := procedure(~l, Kdata, elt, lipr, pmax)
	no:=Integers() ! Abs(Norm(elt));
	if IsDefined(lipr, no) then // meaning no is prime...!
//	    printf "elt=%o no=%o\n", elt, no;
	    if not IsDefined(l, no) then
	        l[no]:=[elt^Kdata["hK"]]; // what a trick!
	    // terrific hack: store one elt per norm in the Galois case!!!!
	    elif (not IsDefined(Kdata, "Galois"))
	    	 and (#l[no] lt Degree(Kdata["K"])) then
	        // l[no] contains distinct prime ideals
		ok:=true;
		// if elt/x is never an integer we gain a new factor
		for i:=1 to #l[no] do
		    x:=l[no][i];
		    r:=elt/x;
		    if IsIntegral(r) then
		        ok:=false;
			break;
		    end if;
		end for;
		if ok then
	 	    l[no]:=Append(l[no], elt);
		end if;
//if #l[no] gt 2 then print l[no]; error("TTTT"); end if;
	    end if;
	end if;
end procedure;

// Perhaps a more carefully used ellipsoid would be better?
EPN3 := function(Kdata, lipr, bounds, pmax)
        OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a1:=0 to bounds[1] do
	    printf "# a1 = %o at %o\n", a1, Cputime();
	    for a2:=-bounds[2] to bounds[2] do
	        for a3:=-bounds[3] to bounds[3] do
		    elt:=a1*OK.1+a2*OK.2+a3*OK.3;
		    InsertInBox(~l, Kdata, elt, lipr, pmax);
	    	end for;
	    end for;
	end for;
	printf "#T# EPN3: %o\n", Cputime(tp);
	return l;
end function;

EPN4 := function(Kdata, lipr, bounds, pmax)
       	OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a1:=0 to bounds[1] do
	    printf "# a1 = %o at %o\n", a1, Cputime();
	    for a2:=-bounds[2] to bounds[2] do
	        for a3:=-bounds[3] to bounds[3] do
	 	    for a4:=-bounds[4] to bounds[4] do
		    	elt:=a1*OK.1+a2*OK.2+a3*OK.3+a4*OK.4;
			InsertInBox(~l, Kdata, elt, lipr, pmax);
	 	    end for;
	    	end for;
	    end for;
	end for;
	printf "# time for EPN4: %o\n", Cputime(tp);
	return l;
end function;

EPN5 := function(Kdata, lipr, bounds, pmax)
       	OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a1:=0 to bounds[1] do
	    printf "# a1 = %o at %o\n", a1, Cputime();
	    for a2:=-bounds[2] to bounds[2] do
	        for a3:=-bounds[3] to bounds[3] do
	 	    for a4:=-bounds[4] to bounds[4] do
		        for a5:=-bounds[5] to bounds[5] do
		    	    elt:=a1*OK.1+a2*OK.2+a3*OK.3+a4*OK.4+a5*OK.5;
			    InsertInBox(~l, Kdata, elt, lipr, pmax);
	 	    	end for;
	 	    end for;
	    	end for;
	    end for;
	end for;
	printf "# time for EPN5: %o\n", Cputime(tp);
	return l;
end function;

EPN6 := function(Kdata, lipr, bounds, pmax)
       	OK:=Kdata["OK"];
        tp:=Cputime();
	l:=AssociativeArray();
	for a1:=0 to bounds[1] do
	  printf "# a1 = %o at %o\n", a1, Cputime();
	  elt1:=a1*OK.1;
	  for a2:=-bounds[2] to bounds[2] do
	    printf "# a2 = %o at %o\n", a2, Cputime();
	    elt2:=elt1+a2*OK.2;
	    for a3:=-bounds[3] to bounds[3] do
	      elt3:=elt2+a3*OK.3;
	      for a4:=-bounds[4] to bounds[4] do
	        elt4:=elt3+a4*OK.4;
		for a5:=-bounds[5] to bounds[5] do
		  elt5:=elt4+a5*OK.5;
		  for a6:=-bounds[6] to bounds[6] do
		    elt6:=elt5+a6*OK.6;
		    InsertInBox(~l, Kdata, elt6, lipr, pmax);
	 	  end for;
	 	end for;
	      end for;
	    end for;
	  end for;
	end for;
	printf "# time for EPN6: %o\n", Cputime(tp);
	return l;
end function;

// OUTPUT: l s.t. l[p] is an element of norm p.
EnumeratePrimeNorms := function(Kdata, lipr, pmax)
        tt:=Cputime();
        U:=Kdata["UK"];		    
	bounds:=FiPoBounds(pmax, Kdata, U["logunits"]);
	printf "# bounds = %o\n", bounds;
	degK:=Degree(Kdata["K"]);
        if degK eq 3 then l:=EPN3(Kdata, lipr, bounds, pmax);
        elif degK eq 4 then l:=EPN4(Kdata, lipr, bounds, pmax);
        elif degK eq 5 then l:=EPN5(Kdata, lipr, bounds, pmax);
        elif degK eq 6 then l:=EPN6(Kdata, lipr, bounds, pmax);
	end if;
	printf "# Card(l)=%o\n", #Keys(l);
if false then
	for no in Keys(l) do
	    if #l[no] lt degK then
	        printf "incomplete: l[%o], %o\n", no, #l[no];
	    end if;
	end for;
end if;
	printf "# entering minimization of generators\n";
	tp:=Cputime();
	for no in Keys(l) do
	    l[no]:=[Minimize(Kdata, x) : x in l[no]];
	end for;
	printf "#T# minimizing generators: %o\n", Cputime(tp);
	printf "#T# enumerating prime norms: %o\n", Cputime(tt);
	return l; 
end function;

// OUTPUT: r(Z) s.t. r(Z) generates Gal(f) if Gal(f) is cyclic,
//         [orb1, orb2, ..., orb_{degK-1}] otherwise.
//	   orb_i = [sig_i, sig_i o sig_i, ..., Z]
GaloisAction := function(K, iscyc)
        t:=K.1;
	KZ<Z>:=PolynomialRing(K);
	fZ:=KZ!Eltseq(DefiningPolynomial(K));
	lr:=Roots(fZ); // lr = [<t, 1>, ...]
//	print lr;
	orbits:=[];
	for i:=1 to #lr do
	    if lr[i][1] eq t then continue; end if;
	    // check for order
	    r:=lr[i][1];
	    rZ:=KZ!Eltseq(r);
	    rj:=r;
	    ord:=1;
	    cyc:=[rZ];
	    for j:=1 to Degree(K) do
	        rj:=Evaluate(rZ, rj);
//		printf "r_%o = %o\n", j, rj;
		if rj eq r then break; end if;
		ord:=ord+1;
		Append(~cyc, KZ!Eltseq(rj));
	    end for;
	    if ord eq Degree(K) then return [cyc]; end if;
	    Append(~orbits, cyc);
	end for;
	printf "# non-cyclic Galois: %o\n", orbits;
	return orbits;
end function;

CheckUnitsModP := procedure(K, unitsW)
	f:=DefiningPolynomial(K);
	d:=Degree(f);
	Phid:=CyclotomicPolynomial(d);
        p:=1000;
	while true do
	    p:=NextPrime(p);
	    Fp:=GF(p);
	    FpZ<Z>:=PolynomialRing(Fp);
	    if IsIrreducible(FpZ!Eltseq(f)) then
		Phidp:=Evaluate(Phid, p);
		lf:=Factorization(Phidp);
		printf "p = %o => Phi_%o(p) = %o\n",p,Degree(f),lf;
		ell:=Max([x[1] : x in lf]);
		if ell gt 10^3 then
	            break;
		end if;
	    end if;
	end while;
	printf "# ell = %o\n", ell;
	Fpd<z>:=ext<Fp | FpZ!Eltseq(f)>;
	for i:=0 to p-1 do
	    gen:=z+i;
	    if Order(gen) eq p^d-1 then break; end if;
	end for;
	printf "# gen = %o\n", gen;
	cof:=(p^d-1) div ell;
	for i:=1 to #unitsW do
	    // find log of eps[i] in T_d
	    eps:=Fpd![Fp ! x : x in Eltseq(unitsW[i])];
	    printf "# eps=%o: frob_p action is\n", eps;
	    for j:=1 to d-1 do
	        printf "  %o\n", eps^(p^j);
	    end for;
	    epsT:=eps^cof;
	end for;
end procedure;

// From Gras79: K cyclic quartic
// G = <sigma>, k quadratic subfield of K
// E_K = unit group of K
// chi relative unit iff chi^(1+sigma^2) = +/- 1
// E_chi = <eps_chi>, u_chi = \pm eps_chi^{mu+nu*sigma}
// E_k = <eps0> = unit group of k
// E^K = E_k + E_chi
// Q_K = (|E_K|:|E^K|) = 1 or 2 by Hasse;
// Q_K = 2 <=> there exists a Minkowski unit eps
//         <=> exists u in E_K s.t. u^{1+sigma^2} = +/- eps_0
//             [as a matter of fact, u = eps]
// Minkowski unit: eps and some of its conjugates form a system
// of fundamental units.
//
    // w is a chi-relative unit of norm -1 over k
    // k = K^<sigma^2> = K_2
    // K has conductor f, k has conductor m, f = m*g
    // (t, z, x, y), r = -6 <=> t^2+16 = m*z^2 or z^2=g*(x^2+y^2)
    // v2(m) = 0 or 3
    // m = a^2+b^2 has a finite number of solutions
    // z^2 = g*(x^2+y^2)
    // t*z = g*(a*(x^2-y^2)-2*b*x*y)
    // t^2+m*z^2 = -16+2*f*(x^2+y^2)
    //
    // when t=1, one has 17=17*1^2, m = 1^2+4^2
    // 1 = g*(x^2+y^2) => g = 1, x = 0 or y = 0
    // t*z = g*(a*(x^2-y^2)-2*b*x*y)
    // 1+17 = -16+2*f => f = 17 => Q_K = 2
    //
    // It is not true that Q_K = 2 for the whole family...
    //
    // if t <= f/2-4, then E_chi = <w>, which is the case for t=1
    //
    // Y = Z-1/Z => Z^2-Y*Z-1 = 0, disc = Y^2+4 > 0
    //
// if QK = 1 then E_K = E^K = E_k (+) E_chi
// all units are +/-eps0^lambda*eps_chi^{mu+nu*sigma}
// for lambda, mu, nu in Z [p. 7]
// UK is <-1, eps0, eps_chi, eps_chi^sigma>
//
// TODO: we are in a mixed state: f_t(X) and general case.
// OUTPUT: <>, [ord]
Gras4 := function(K, conjW)
        if conjW eq [] then
	    conjW[1]:=K.1;
	    for i:=2 to 3 do
	    	conjW[i]:=(conjW[i-1]-1)/(conjW[i-1]+1);
	    end for;
	end if;
	KZ:=PolynomialRing(K);
	r:=K.1;
	OK:=MaximalOrder(K);
	UK,map:=UnitGroup(K);
	units:=[map(u) : u in Generators(UK)];
	QK:=0;
        for i:=1 to #units do
	    tmp:=Norm(units[i]);
	    printf "units[%o] has norm %o\n", i, tmp;
	    if tmp eq -1 then
	        printf "# norm = -1 => QK = 2\n";
	        QK:=2;
	    end if;
	end for;
	printf "# w^(1+sigma^2)=%o\n", conjW[1]*conjW[3];

	eps_chi:=conjW[1]; // when t is small enough w.r.t. f

        K2:=Subfields(K, 2);
	K2,map2K:=Explode(K2[1]);
	printf "K2=%o; map=%o;\n", K2, map2K;
	unitsK2,map2:=UnitGroup(K2);
	eps0:=K2!map2(unitsK2.2);
	printf "UK2=%o: eps0=%o [%o] -> %o\n", unitsK2, eps0, Norm(eps0),
	       		map2K(eps0);

	if Norm(eps0) eq -1 and QK eq 0 then
	    printf "Norm(eps0) = -1 => QK = 1\n";
	    QK:=1;
	end if;

	if QK eq 0 then
	    printf "# could not find QK\n";
	elif QK eq 1 then
	    // all units are +/-eps0^lambda*eps_chi^{nu+v*sigma}
	    // UK = <-1, eps0, eps_chi, eps_chi^{sigma}>
	    unitsM:=[eps0, eps_chi, Evaluate(KZ!Eltseq(eps_chi), conjW[2])];
	elif QK eq 2 then
	    // after that, we need solve W^2 = +/- eps0*eps_chi^{1-sigma}
	    // when t is small enough w.r.t. f, then E_chi = <w>
	    W2:=map2K(eps0)*conjW[1]/conjW[2];
	    lr:=Roots(KZ.1^2-W2);
	    printf "# Z^2-W2=%o\n", lr;
	    if #lr eq 0 then
		lr:=Roots(KZ.1^2+W2);
	    	printf "# Z^2+W2=%o\n", lr;
	    end if;
	    if #lr eq 2 then
	        W:=lr[1][1];
		// normalize!
		tmp:=Eltseq(W);
		if tmp[1] eq 0 then error("stupid miss"); end if;
		if tmp[1] lt 0 then W:=-W; end if;
	    else
	        error("No squareroot", lr);
	    end if;
	    printf "# W_normalized = %o\n", W;
	    // UK = <-1, W, W^sigma, W^{sigma^2}>
	    Wsig:=Evaluate(KZ!Eltseq(W), conjW[2]);
	    Wsig2:=Evaluate(KZ!Eltseq(Wsig), conjW[2]);
	    unitsM:=[W, Wsig, Wsig2];
	end if;
	printf "QK=%o; unitsM=%o\n", QK, unitsM;
	CheckUnitsModP(K, unitsM);
	
//	KK<[a]>:=PolynomialRing(K, 4);
//	u:=&+ [ a[i+1] * r^i : i in [0..3] ];
//	u2:=&+ [ a[i+1] * units[3]^i : i in [0..3] ];
//	print u*u2-map(eps0);
//	UnitPolyEq(Kdata, 1+X^2, map(eps0));
	return [-1] cat unitsM, [2] cat [0 : u in unitsM] ;
end function;

// We need fundamental units, and in some cases, we want always the same
// answer.
// If r1 > 0, u0 = -1 is a unit.
// Torsion units are ignored, since their logs are 0 mod ell.
// OUTPUT: units[1..rK+1], orders
// where units[1] is the torsion unit (if none, then units[1] = 1) and
// units[2..rK+1] are fundamental units.
GetUnits := function(K, OK)
	pol:=DefiningPolynomial(K);
	if pol eq X^4+1 then
	    printf "# I recognize K = Q(zeta_8)\n";
	    return [OK!K.1, OK!(K.1^2-K.1+1)], [8, 0];
	elif pol eq X^6+X^5+X^4+X^3+X^2+X+1 then
	    printf "# I recognize K = Q(zeta_7)\n";
	    return [-OK!K.1, OK!(K.1^4+K.1^3), OK!(-K.1^5-K.1^4-K.1^3-K.1^2)],
	    	   [14, 0, 0];
	elif Degree(K) eq 3 then
	    // is it X^3-A*X^2-(A+3)*X-1
	    if Coefficient(pol, 0) eq -1 and (-Coefficient(pol, 2)+3) eq -Coefficient(pol, 1) then
	        printf "# I recognize cyclic cubic real\n";
		return [-1, K.1, K.1+1], [2, 0, 0];
	    end if;
	elif Degree(K) eq 4 then
	    // is it cyclic quartic real?
	    // X^4-A*X^3-6*X^2+A*X+1
		if Coefficient(pol, 0) eq 1 and Coefficient(pol, 2) eq -6
		   and Coefficient(pol, 1) eq -Coefficient(pol, 3) then
		   printf "# I recognize K cyclic quartic real of deg 4\n";
		   return Gras4(K, []);
		end if;
	end if;
	UK,map:=UnitGroup(K);
	units:=[];
	ord:=[];
	// torsion unit first
	for gen in Generators(UK) do
	    if Order(gen) ne 0 then
	        units[#units+1]:=OK!map(gen);
		ord[#ord+1]:=Order(gen);
		printf "torsion: %o %o\n", units[#units], ord[#ord];
	    end if;
	end for;
	// units of infinite order
	for gen in Generators(UK) do
	    if Order(gen) eq 0 then
	        units[#units+1]:=OK!map(gen);
		ord[#ord+1]:=0;
	    end if;
	end for;
	printf "# units = %o\n", units;
	return units, ord;
end function;

// u_1, ..., u_ell with ell = r1+r2-1; if r1 > 0, u0 = -1.
// We suppose f has real roots alpha_1, ..., alpha_{r_1}
// and complex roots alpha_{r_1+1}, ..., alpha_n
// s.t. alpha_{r_1+r_2+j} is the complex conjugate of alpha_{r_1+j}
// for 1 <= j <= r_2. Note that r1+2*r2 = n = deg(K) = deg(f).
// For 1 <= i <= ell, varphi_i(alpha) = alpha_i.
// U["units"] will contain units in OK as EltSeq.
PrepareUnits := procedure(~U, ~G, Kdata, genG)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	r1,r2:=Signature(K);
	rK:=r1+r2-1;
	printf "# r1=%o, r2=%o => rK=%o\n", r1, r2, rK;
	lr:=Kdata["roots"];
	units,ord:=GetUnits(K, OK);
//	printf "# units_OK = %o\n", units;
	printf "# units_K = %o\n", [K!u : u in units];
	// build matrix
	M:=KMatrixSpace(RR, rK, rK)!0;
	for i:=2 to #units do
	    // fill in the i-th column
	    fui:=AlgToReal(K!units[i]);
	    if DLP_DEBUG ge 2 then
	        printf "i=%o => %o = %o\n", i, K!units[i], fui;
	    end if;
	    for j:=1 to rK do
	        M[j, i-1]:=Log(Abs(Evaluate(fui, lr[j])));
	    end for;
	end for;
//	printf "M=\n%o\n", M;
	// boxes will have bound^{2*rK} points
	if rK le 2 then bound:=20;
	elif rK le 3 then bound:=10;
	elif rK le 4 then bound:=10;
	else bound:=5; end if;
	if ord[1] ne 0 then
	    bounds:=[ord[1]-1] cat [bound : i in [2..#units]];
	else
	    bounds:=[bound : i in [1..#units]];
	end if;
	if genG then
	    printf "# BuildGroupTable with bounds %o\n", bounds;
	    tp:=Cputime();
	    G:=BuildGroupTable(units, bounds);
	    printf "#T# BGT: %o\n", Cputime(tp);
	end if;
	U["units"]:=units;
	U["rK"]:=rK;
	U["Minv"]:=M^(-1);
	U["logunits"]:=[AllEmbeddings(Kdata, K!units[i]) : i in [2..#units]];
end procedure;

// INPUT: niceK means we may compute many invariants of K.
// OUTPUT: { Galois, K, roots, rK, hK, UK, OK }
PrepareField := function(K, niceK)
	r1,r2:=Signature(K);
	Kdata:=AssociativeArray();
	Kdata["K"]:=K;
	Kdata["rK"]:=r1+r2-1;
	if not niceK then return Kdata; end if;
	f:=DefiningPolynomial(K);
	if r2 eq 0 then
	    lr:=[r[1] : r in Roots(AlgToReal(f))];
	elif r1 eq 0 then
	    lr0:=[r[1] : r in Roots(AlgToComplex(f))];
	    if DLP_DEBUG ge 3 then printf "lr0=%o\n", lr0; end if;
	    // assuming that roots are [alpha1, conj(alpha1), ...]
	    // reorder them to [alpha1, alpha2, ..., alpha_r2, conj(alpha1)...]
	    lr:=[];
	    for i:=1 to r2 do
	        lr[i]:=lr0[2*i-1];
		lr[i+r2]:=lr0[2*i];
	    end for;
	elif Degree(f) eq 3 then
	    // at this point, we have sign = (1, 1)
	    lr:=[r[1] : r in Roots(AlgToComplex(f))];
	elif Degree(f) eq 5 then
	    // do we care, really?
	    lr:=[r[1] : r in Roots(AlgToComplex(f))];
	else
	    // TODO: order roots of f...!
	    error("NYI in PrepareField");
	end if;
	printf "# ordered roots: %o\n", lr;
	Kdata["OK"]:=MaximalOrder(K);
	printf "OK = %o\n", [K!Kdata["OK"].i : i in [1..Degree(K)]];
	Kdata["roots"]:=lr;
	gal:=GaloisGroup(DefiningPolynomial(K));
//	printf "# Galois group:\n%o\n", gal;
	iscyc:=IsCyclic(gal);
	Kdata["Galois"]:=<iscyc, GaloisAction(K, iscyc)>;
	if iscyc then printf "# Galois(f) is cyclic\n"; end if;
//	printf "# Galois action:\n%o\n", Kdata["Galois"];
	Kdata["hK"]:=ClassNumber(K);
	printf "# hK = %o\n", Kdata["hK"];
	U:=AssociativeArray();
	PrepareUnits(~U,~G,Kdata,niceK);
	if niceK then // FIXME niceK -> generate?
	    U["grouptable"]:=G;
	    if DLP_DEBUG ge 3 then
	        for key in Keys(G) do
		    printf "G[%o]=%o\n", key, G[key];
		end for;
	    end if;
	end if;
	Kdata["UK"]:=U;
	return Kdata;
end function;

// If x is not close enough to an integer, do not round it!
// TODO: understand this 0.3, which appeared due to p2dd10-f4g2-1mod2-t1--12
Roundify := function(x)
	prec:=Precision(x);
	ix:=Round(x);
	if Abs(ix-x) gt 10^(-0.25 * prec) then // humf!
	    printf "## x = %o\n", x;
	    printf "## |x-ix| = %o\n", Abs(x-ix);
	    error("Precision pb?");
	end if;
	return ix;
end function;

// INPUT: Keys(U) = {"grouptable", "roots", "units", "rK"}
//        eta is in OK.
// OUTPUT: [e_0, e_1, ..., e_{rK}] where eta = prod units[i]^e_i
// 	   true/false if floating point recovery had to be performed   
// e_0 is the exponent of the torsion unit (0 if recovered with floating
// point -- sheer lazyness).
RecoverUnits := function(Kdata, eta)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	U:=Kdata["UK"];
	G:=U["grouptable"];
	if IsDefined(G, eta) then
	    if DLP_DEBUG ge 3 then
	        printf "# RC[%o]=%o\n", eta, G[eta];
	    end if;
	    return G[eta], false;
	end if;
//if not DLP_USE_UNITS_FLOAT or eta eq 1 or eta eq -1 then return eps; end if;
//	if DLP_DEBUG ge 2 then printf "Found eps = %o\n", eps; end if;
	rK:=U["rK"];
	lr:=Kdata["roots"];
	// don't forget to send eta in K...
//	V:=[Log(Abs(Evaluate(AlgToReal(K!eta), lr[i]))) : i in [1..rK]];
	V:=AllEmbeddings(Kdata, K!eta);
	if DLP_DEBUG ge 2 then
	    printf "V = %o\n", V;
	end if;
	eps:=[];
	// compute Minv * V
	for i:=1 to rK do
	    tmp:=&+ [ U["Minv"][i, j] * V[j] : j in [1..rK] ];
	    eps[i]:=Roundify(tmp);
	    if DLP_DEBUG ge 2 then
	        printf "%o -> %o = %o\n", i, tmp, eps[i];
	    end if;
	end for;
	chk:=&* [U["units"][i+1]^eps[i] : i in [1..rK]];
	// chk/eta should be a torsion unit
	tmp:=OK!(chk/eta);
	if not IsTorsionUnit(tmp) then
	    printf "No torsion unit: %o %o -> %o\n", eta, chk, tmp;
	    error("Bad check between units");
	end if;
	if DLP_DEBUG ge 2 then
            printf "# floating point recovery for %o: %o, %o\n", eta, eps, tmp;
	end if;
//	printf "#W# TO BE DONE: power of the torsion unit?";
//error("TBD");
	return [0] cat eps, true;
end function;

// lr contains the roots of f(X) mod p without multiplicity.
// WARNING: does work for easy examples only...!
// OUTPUT: [[c1, p1, e1], ..., [ck, pk, ek]], 
// e_i = ramification index, f_i = residual degree.
GetIdeals := function(K, OK, p, lr)
	lgp:=[];
	eta:=p;
	if #lr eq 1 then
	    // resort to Magma
	    r:=lr[1];
	    lf:=Factorization(p * OK);
	    printf "(%o) = %o\n", p, lf;
	    for id in lf do
	        ok,gp:=IsPrincipal(id[1]);
	    	if not ok then error("Not principal"); end if;
		// check this?
		for i:=1 to id[2] do
		    eta:=eta / gp;
		end for;
		lgp[#lgp+1]:=<r, gp, id[2]>;
	    end for;
	elif #lr eq Degree(K) then
	    tmp:=[0 : i in [1..Degree(K)-2]];
	    for r in lr do
	    	id:=ideal<OK | [p, 0] cat tmp, [p-r, 1] cat tmp>;
//	    	printf "id=%o, Norm=%o\n", id, Norm(id);
	    	ok,gp:=IsPrincipal(id);
//		printf "gen(id)=%o\n", gp;
	    	if not ok then error("Not principal"); end if;
	    	lgp[#lgp+1]:=<r, gp, 1>;
	    	eta:=eta / gp;
	    end for;
	else
	    error("#lr not permitted yet");
	end if;
	if DLP_DEBUG ge 2 then printf "lgp = %o\n", lgp; end if;
	if #lgp eq Degree(K) then
	    // a free relation
	    if DLP_DEBUG ge 2 then
	        printf "free relation: p = %o, eta = %o of norm %o\n", 
	    	   p, OK!eta, Norm(eta);
	    end if;
	end if;
	if Abs(Norm(eta)) ne 1 then error("Not a unit"); end if;
	return <lgp, OK!eta>;
end function;

// We should have f(c) = 0 mod p
UpdateFB := procedure(~FB, Kdata, U, p, c)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	f:=DefiningPolynomial(K);
        if DLP_DEBUG ge 2 then
	    printf "# computing roots of f mod %o\n", p;
	end if;
	FpX<X>:=PolynomialRing(GF(p));
	fp:=FpX!Eltseq(f);
	if Evaluate(fp, c) ne 0 then error("not a root"); end if;
if false then // false for ramified primes!!!!!
		    fp:=fp div (X-c);
		    lr:=Roots(fp);
		    lr:=[c] cat [Integers()!r[1] : r in lr];
else
	lr:=Roots(fp);
	lr:=[Integers()!r[1] : r in lr];
end if;
	FBp:=GetIdeals(K, OK, p, lr);
	if FBp[2] ne 0 then
	    // free relation: recover eps...!
	    eps:=RecoverUnits(Kdata, FBp[2]);
	    if eps eq [] then error("No unit found"); end if;
	    FBp:=<FBp[1], eps>;
	end if;
	FB[p]:=FBp;
	if DLP_DEBUG ge 2 then printf "FB[%o]=%o\n", p, FB[p]; end if;
end procedure;

// p^ex || norm.
// INPUT: FB[p] = <[<c1, gen1, e1>, ..., <ck, genk, ek>], eps_p>
// 	  where id1 = [p, p-c1], ...
//	  eta should be in OK
// Remember that (p) = p*OK = prod_{i=1}^g P_i^e_i, where Norm(P_i) = p^f_i
// and sum_i e_i f_i = n = degree(K).
// If K is abelian (e.g., cyclic), e_i = e, f_i = f and e*f*g = n.
// An inert prime is (1, n, 1).
// For non inert primes:
// n prime: (e, f, g) = (1, 1, n) or (n, 1, 1);
// n = 4: (1, 1, 4) or (2, 2, 1) or (2, 1, 2) or (1, 2, 2).
DivideGivenNorm := procedure(~eta, K, OK, FB, p, ex, c)
        n:=Degree(K);
	g:=#FB[p][1];
	// abelian case only, easy to change
	e:=FB[p][1][1][3]; // ramification index
	f:=n div (g*e);    // residual degree
	ok:=false;
	for ee:=1 to (ex div f) do
	    for id in FB[p][1] do
	    	if id[1] eq c then
	            tmp:=eta/OK!id[2];
// print id[2], tmp, Norm(tmp);
		    // this will solve the multiple roots pb
		    if IsIntegral(tmp) then
		        eta:=tmp;
		        ok:=true;
		    end if;
	    	end if;
	    end for;
	end for;
	if not ok then error("No ideal found"); end if;
end procedure;

// lf = factorization of Norm(a-b*t) = [<p1, ex1>, ...]
Treat_a_b := procedure(~FB, ~eps, Kdata, U, a, b, lf)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	t:=K.1;
	if DLP_DEBUG ge 2 then printf "a=%o, b=%o: %o\n", a, b, lf; end if;
	theta:=(a-b*t);
	eta:=OK!theta;
	for pe in lf do // code_123
	    p,ex:=Explode(pe);
	    if b mod p eq 0 then
	        error("b = 0 mod p: NYI", b);
	    else
		c:=(a * Modinv(b, p)) mod p;
		if not IsDefined(FB, p) then
		    UpdateFB(~FB, K, OK, U, p, c);
		end if;
		DivideGivenNorm(~eta, K, OK, FB, p, ex, c);
	    end if;
	    if DLP_DEBUG ge 3 then
	        printf "new theta=%o\n", eta;
	    end if;
	end for;
	eta:=OK!eta;
	if DLP_DEBUG ge 2 then
	    printf "eta=%o => Norm=%o\n", eta, Norm(eta);
	end if;
	eps:=RecoverUnits(Kdata, eta);
	if eps eq [] then error("no unit found for ", eta); end if;
	if DLP_DEBUG ge 2 then
	    printf "eps=%o\n", eps;
	end if;
end procedure;

TreatFromFile := procedure(~FB, ~epsab, p, f, g, m, Kdata, fic)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	U:=Kdata["UK"];
	t:=K.1;
        fd:=POpen("gzip -dc " * fic, "r");
	nr:=0;
	while true do
	    s:=Gets(fd);
            if IsEof(s) then break; end if;
	    // skip comments
	    if s[1] eq "#" then continue; end if;
	    // s = "88723,10093:3,3,3,3,5,1d,1af,42d,1db7,4b13,beead:13,25,e9,5029,30d51"
	    tmp:=Split(s, ":");
	    ab:=Split(tmp[1], ",");
	    nr:=nr+1;
	    if nr mod 1000 eq 0 then
	        printf "# %o relations treated at %o\n", nr, Cputime();
	    end if;
//	    printf "R%o: %o\n", nr, ab;
	    a:=StringToInteger(ab[1]);
	    b:=StringToInteger(ab[2]);

	    // recover factorization from rational part
	    // which is "3,3,3,3,5,1d,1af,42d,1db7,4b13,beead" where numbers
	    // are actual primes
	    if DLP_VERIFICATION then
	        abm:=a-b*m;
//	    	lg:=Factorization(a-b*m);
//	    	printf "lg = %o // %o\n", lg, tmp[2];
	    	rat:=Split(tmp[2], ",");
	    	lg:=[];
	        for p in rat do
	            pp:=StringToInteger(p, 16);
		    if abm mod pp ne 0 then error(abm, pp); end if;
		    abm:=abm div pp;
		    lg[#lg+1]:=pp;
	    	end for;
//	    	printf "cof(abm)=%o\n", abm;
	    	if Abs(abm) ne 1 then error("|cof| != 1"); end if;
	    end if;

	    // algebraic part: "13,25,e9,5029,30d51" where numbers are actual
	    // primes dividing the norm of a-b*t
	    no:=Integers()!Norm(a-b*t);
	    alg:=Split(tmp[3], ",");
	    lf:=[];
if false then // code_123
	    for p in alg do
	        pp:=StringToInteger(p, 16);
		if no mod pp ne 0 then error(no, pp); end if;
		no:=no div pp;
		lf[#lf+1]:=pp;
	    end for;
else // not faster! but more convenient
	    ppold:=0;
	    for p in alg do
	        pp:=StringToInteger(p, 16);
		if pp ne ppold then
	  	    ex,no:=Valuation(no, pp);
		    if ex eq 0 then error(no, pp); end if;
		    lf[#lf+1]:=<pp, ex>;
		    ppold:=pp;
		end if;
	    end for;
end if;
//	    printf "cof(no)=%o\n", no;
	    if Abs(no) ne 1 then error("|cof| != 1"); end if;

	    Treat_a_b(~FB, ~eps, Kdata, U, a, b, lf);
	    epsab[[a, b]]:=eps;
//break;
	end while;
if false then
        // compute stats here...!
	stats:=AssociativeArray();
	if IsDefined(stats, eps) then
	    stats[eps]:=stats[eps]+1;
	else
	    stats[eps]:=1;
	end if;
	for k in Keys(stats) do
	    printf "%o %o\n", stats[k], k;
	end for;
end if;
end procedure;

// U = <G, rt, funits>
// OUTPUT: epsab[a, b] = unit in factorization of a-b*alpha
TreatFromDir := procedure(~FB, ~epsab, p, f, g, Kdata, dir)

m:=0;

	tmp:=dir * ".units.listfiles";
	cmd:="ls " * dir * ".sieving* > " * tmp;
        System(cmd);
	fd:=Open(tmp, "r");
	nf:=0;
	while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    nf:=nf+1;
	    printf "## Operating on file %o: %o\n", nf, s;
	    TreatFromFile(~FB, ~epsab, p, f, g, m, Kdata, s);
	end while;
end procedure;

// Useful for verifying.
ReadFactorBase := procedure(~FB, Kdata, fb, degf)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	printf "# Reading factor base from %o\n", fb;
	f:=DefiningPolynomial(K);
	t:=K.1;
        fd:=POpen("gzip -dc " * fb, "r");
	while true do
	    s:=Gets(fd);
            if IsEof(s) then break; end if;
	    if s[1] eq "#" then continue; end if;
	    tmp:=Split(s, ":");
	    if #tmp eq 3 then 
	        if DLP_DEBUG ge 2 then printf "powers? %o\n", tmp; end if;
		continue;
	    end if;
	    p:=StringToInteger(tmp[1]);
	    tmp:=Split(tmp[2], ",");
	    // "3: 2" special???
	    if #tmp lt Degree(f) then
	        printf "ramified? p=%o => %o\n", p, tmp;
	    end if;
	    // "17: 7,13,14" normal case
	    lr:=[StringToInteger(tmp[i]) : i in [1..#tmp]];
//	    printf "p = %o => lr = %o\n", p, lr;
	    // p*OK has factors [p, t-r]
//	    printf "p*OK = %o\n", Factorization(p*OK);
	    FBp:=GetIdeals(K, OK, p, lr);
	    if FBp[2] ne 0 then
	        eps:=RecoverUnits(Kdata, FBp[2]);
          	if eps eq [] then error("No unit found"); end if;
                FBp:=<FBp[1], eps>;
	    end if;
	    FB[p]:=FBp;
	    if DLP_DEBUG ge 2 then
	        printf "FB[%o]=%o\n", p, FB[p];
	    end if;
//if p gt 50 then error("TBC"); end if;
	end while;	      
end procedure;

// From README.fileformat:
// File XXX.purged.gz
// ==================
// 
// It is created by purge, and contains a set of relations without
// singleton, and where all or almost all the excess has been used.
// 
// The first line has the following format:
// # nr lc nc
// where
//   - nr is the number of rows (relations)
//   - lc is the index of the last column (ideal) that has non-zero weight
//   - nc is the number of columns (ideals)
// nr, lc and nc are written in decimal.
// 
// Then, each line of the file corresponds to one relation: a,b:h_0,....h_k
// where
//   - a and b give the (a,b) pair of the original relation
//   - h_i is an index of an ideal appearing in the relation. For factorization, an
//     ideal appears at most one per relation. For DL, if an ideal more than
//     once in the relation, all these occurences are guaranteed to be one after
//     the other.
// a,b and the h_i's are in hexadecimal.
//
// OUTPUT: [[a, b]] or [[a, b, h_0, ..., h_x]]
DLDumpPurged := function(purged, abonly)
        abp:=[];
        fd:=POpen("gzip -dc " * purged, "r");
	s:=Gets(fd);
	// read first line: s = "# 10807 37271 10805"
	tmp:=Split(s, " ");
	nr:=StringToInteger(tmp[2]);
	lc:=StringToInteger(tmp[3]);
	nc:=StringToInteger(tmp[4]);
	printf "# nr = %o, lc = %o, nc = %o\n", nr, lc, nc;
	foo:=[];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "-ad21b,8217:4,6,6,c,18,166,1c9,5f4,ad3,1fbc,14,8e,7e7,e23,8d73,0"
	    tmp:=Split(s, ":");
	    if not abonly then
	        foo:=Split(tmp[2], ",");
	        foo:=[StringToInteger(x, 16) : x in foo];
	    end if;
	    tmp:=Split(tmp[1], ",");
	    a:=StringToInteger(tmp[1], 16);
	    b:=StringToInteger(tmp[2], 16);
	    Append(~abp, [a, b] cat foo);
	end while;
	return abp;
end function;

ReadBadIdeals := function(K, badidealinfo)
	printf "# reading badidealinfo\n";
	fd:=Open(badidealinfo, "r");
	bad:=[];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    print s;
	    // s = "### 3 (2 : 1) 1 [ 1 ] (i=1: ramified, e=3) ; easy."
	    tmp:=Split(s, " ");
	    if "easy." in tmp then
		pp:=StringToInteger(tmp[2]);
if false then // TODO: understand all this?
		e:=Split(s, "=");
		// e[2] = "1: ramified, e"
		i:=Split(e[2], ":");
		i:=StringToInteger(i[1]);
		// e[3] = "3) ; easy."
		e:=Split(e[3], ")");
		e:=StringToInteger(e[1]);
		// in the abelian case, i*e*f = n
		f:=Degree(K) div (i*e);
		bad[#bad+1]:=<pp, i, e, f>;
else
		bad[#bad+1]:=<pp>;
end if;
	    else
	        error("Case not easy NYI");
	    end if;
	end while;
	return bad;
end function;

// OUTPUT: <elt_of_K, e, f>
GeneratorForBad := function(Kdata, p, id)
	lf:=Factorization(id);
//	printf "# p=%o, id=%o => lf=%o\n", p, id, lf;
	if #lf ne 1 then error("PB??"); end if;
	lf1h:=lf[1][1]^Kdata["hK"];
	ok,gp:=IsPrincipal(lf1h);
	if not ok then error("Not principal in GeneratorForBad"); end if;
	// lf[1][2] is the ramification index
	return <Kdata["K"]!gp, lf[1][2], Degree(lf[1][1])>;
end function;

GetGeneratorFromScratch := function(Kdata, id)
	tp:=Cputime();
	ok,gp:=IsPrincipal(id^Kdata["hK"]);
	tp:=Cputime(tp);
	if tp gt 1.0 then
	    printf "#T# pcp: %o\n", tp;
	end if;
	if not ok then return false, 0, 0, 0; end if;
	tp:=Cputime();
	return true, gp, Minimize(Kdata, Kdata["K"]!gp), Cputime(tp);
end function;

GetGeneratorForqr := function(Kdata, q, r)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	zero:=[0 : i in [1..Degree(K)-2]];
	id:=ideal<OK | [q, 0] cat zero, [q-r, 1] cat zero>;
	ok,_,gen:=GetGeneratorFromScratch(Kdata, id);
	return gen;
end function;

// INPUT: fo = file descriptor
//        i = index
//        gef = <gp, ep, fp> with gp in K
PrintGenerator := procedure(fo, i, gef, isbad)
	if isbad then
	    gp,ep,fp:=Explode(gef);
	else
	    gp:=gef; ep:=1; fp:=1;
	end if;
	den:=Denominator(gp);
	tmp:=Eltseq(den*gp);
	fprintf fo, "%o", i;
	if ep eq 1 and fp eq 1 then
	    // ordinary case
	    fprintf fo, " %o", den;
	else
	    fprintf fo, " %o %o", -ep, fp;
	    fprintf fo, " %o", den;
	end if;
	for j:=1 to #tmp do
	    fprintf fo, " %o", tmp[j];
	end for;
	fprintf fo, "\n";
end procedure;

// elt has norm p; we look for some Galois tau s.t. tau(elt) = [p, r]
InspectIdeals := procedure(p, r, Kdata, elt)
        FpW<W>:=PolynomialRing(GF(p));
	K:=Kdata["K"];
	deg:=Degree(K);
	t:=K.1;
	galac:=Kdata["Galois"];
	zero:=[0 : i in [1..deg-2]];
        id:=ideal<Kdata["OK"] | [p, 0] cat zero, [p-r, 1] cat zero>;
	ok,gen:=IsPrincipal(id);
	printf "gen(%o, %o)=%o\n", p, r, K!gen;
	eltW:=FpW!Eltseq(K!elt);
	for cyc in galac[2] do
	  for sig in cyc do
	    // sigma(r) = e or sigma^(-1)(e) = r
	    eltZ:=PolynomialRing(K)!Eltseq(K!elt);
	    sigt:=&+ [Coefficient(sig,i)*t^i : i in [0..Degree(sig)]];
	    gp:=Evaluate(eltZ, sigt);
	    printf "sig=%o => gp=%o (%o)\n", sig, gp, Norm(gp);
	  end for;
	end for;
end procedure;

// OUTPUT: ok, PZ(r) mod p.
RatEvaluate := function(FpW, PZ, r)
	den:=Lcm([Denominator(Coefficient(PZ, i)) : i in [0..Degree(PZ)]]);
	p:=#BaseRing(FpW);
	if (den mod p) eq 0 then
	    printf "den = 0!!!!\n";;
	    return false, 0;
	end if;
	return true,Evaluate(FpW!Eltseq(PZ), r);
end function;

// [q, X-r] = <gen>, where gen is in OK
// OUTPUT: r
FindrGivenGenerator := function(K, q, gen)
        FpW<W>:=PolynomialRing(GF(q));
	genW:=FpW!Eltseq(K!gen);
	g:=Gcd(genW, FpW!Eltseq(DefiningPolynomial(K)));
	if DLP_DEBUG ge 2 then
	    printf "# Gcd = %o\n", g;
	end if;
	if Degree(g) ne 1 then
	    printf "# Gcd = %o mod %o\n", g, q;
//	    InspectIdeals(q, r, Kdata, gen);
	    error("Degree(g) != 1");
//	    return false, 0;
	end if;
	return -Coefficient(g, 0);
end function;

// INPUT: lp a list of elements in K of norm p; id = [p, alpha-r] an ideal.
// OUTPUT: true/false, a generator for id found using conjugates of elt
// 	   under Galois.
// For this, we use:
// 1. elt*OK=[p, alpha-e] generates id <=> eltW(e) = 0.
// 2. sigma([p, alpha-r]) = [p, alpha-sigma^(-1)(r)].
// So that we want to find sigma s.t. sigma^(-1)(e) = r, in which case
// sigma(elt) will generate id; this test is also e = sigma(r).
FindGeneratorWithGalois := function(p, r, Kdata, lp)
        FpW<W>:=PolynomialRing(GF(p));
	K:=Kdata["K"];
	t:=K.1;
	galac:=Kdata["Galois"];
	if not galac[1] then return false, 0; end if;
	for elt in lp do
	    e:=FindrGivenGenerator(K, p, elt);
	    if DLP_DEBUG ge 2 then
	        printf "# root(%o) = %o\n", elt, e;
	    end if;
	    for cyc in galac[2] do
	      for sig in cyc do
	        ok,rr:=RatEvaluate(FpW, sig, r);
		if not ok then return false, 0; end if;
		if DLP_DEBUG ge 2 then
	 	    printf "## (%o)(%o)=%o\n", sig, r, rr;
		end if;
		if rr eq e then
		    // sigma(r) = e or sigma^(-1)(e) = r
		    eltZ:=PolynomialRing(K)!Eltseq(K!elt);
		    sigt:=&+ [Coefficient(sig,i)*t^i : i in [0..Degree(sig)]];
		    gp:=Evaluate(eltZ, sigt);
		    return true, K!Eltseq(gp), sig;
		end if;
	      end for; // for sig
	    end for; // for cyc
	end for;
	error("no generator found");
	return false, 0;
end function;

ReadAlgpr := procedure(~lipr, ~pamax, algpr, f)
	printf "# Reading file %o\n", algpr;
        fd:=POpen("gzip -dc " * algpr, "r");
	lipr:=AssociativeArray();
	npr:=0;
        while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    npr:=npr+1;
	    if npr mod 100000 eq 0 then
	        printf "# reading %o-th ideal at %o\n", npr, Cputime();
	    end if;
	    // s = "i p r"
	    tmp:=Split(s, " ");
	    i:=StringToInteger(tmp[1], 16);
	    p:=StringToInteger(tmp[2], 16);
	    r:=StringToInteger(tmp[3], 16);
	    // patch_begin
//	    if (Integers()!Evaluate(f, r)) mod p ne 0 then continue; end if;
	    // patch_end
	    if IsDefined(lipr, p) then
if false then
	        // patch again_begin
		ok:=true;
		for ir in lipr[p] do
		    if ir[2] eq r then ok:=false; break; end if;
		end for;
		if not ok then continue; end if;
		// patch again_end
end if;
	        lipr[p]:=Append(lipr[p], <i, r>);
	    else
	        lipr[p]:=[<i, r>];
	    end if;
	    pamax:=p;
	end while;
end procedure;

BatchGenerators := procedure(~good, ~bad, generators, Kdata, badp, lipr, 
		   		    ldone, algprimes)
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	zero:=[0 : i in [1..Degree(K)-2]];
	imin:=-1;
	imax:=-1;
	tot:=Cputime();
	totmb:=0.0;
	totmin:=0.0;
	npcp:=0;
	ndone:=0;
	npr:=0;
	for p in algprimes do
	  npr:=npr+1;
	  if npr mod 1000 eq 0 then
	        printf "# computing generator for %o-th ideal[%o] at %o\n", 
		       npr, p, Cputime();
	  end if;
	  for ir in lipr[p] do
	    i,r:=Explode(ir);
	    if imin eq -1 or i lt imin then imin:=i; end if;
	    if imax eq -1 or i gt imax then imax:=i; end if;
	    id:=ideal<OK | [p, 0] cat zero, [p-r, 1] cat zero>;
	    if p in badp then
	        printf "bad: id(<%o, %o>) = %o\n", p, r, id;
	        bad[i]:=GeneratorForBad(Kdata, p, id);
	    else
		ok:=false;
		if IsDefined(ldone, p) then
		    tp:=Cputime();
//		    printf "%o: %o\n", lipr[p], #ldone[p];
		    ok,gp:=FindGeneratorWithGalois(p, r, Kdata, ldone[p]);
		    totmb:=totmb+Cputime(tp);
		    if ok then
//		        printf "FG(%o, %o) -> %o (%o)\n", p, r, gp, Norm(gp);
//		    	assert(gp in id);
			tp:=Cputime();
			good[i]:=Minimize(Kdata, K!gp);
			totmin:=totmin+Cputime(tp);
		    	ndone:=ndone+1;
		    end if;
//		    if not ok then printf "missed\n"; end if;
//		    printf "# membership: %o %o\n", #l[p], Cputime(tp);
		end if;
		if ok then
//		    printf "found: %o\n", good[i][1];
//		    Exclude(~l[p], good[i][1]);
		else // most probably, lp[p] = NULL
		    if DLP_DEBUG ge 2 then
		        printf "I need to principalize: %o %o^%o\n", 
		    	          p, ir, Kdata["hK"];
		    end if;
		    tp:=Cputime();
		    ok,gp,gen,tp2:=GetGeneratorFromScratch(Kdata, id);
		    if not ok then error("Not principal in Gen"); end if;
		    good[i]:=gen;
		    totmin:=totmin+tp2;
		    // trick: add it to lp[]
		    npcp:=npcp+1;
		    ldone[p]:=[K!gp]; // why not gen???
		end if;
	    end if;
//if i gt 20 then error("FFF"); end if;
	  end for;
	end for;
	printf "#T# imin=%o imax=%o totpcp=%o totmb=%o totmin=%o npcp=%o ndone=%o\n", 
	       imin, imax, Cputime(tot), totmb, totmin, npcp, ndone;
	tp:=Cputime();
        fo:=POpen("gzip -c > " * generators, "w");
	// TODO: to be sure, we should print OK and/or the units?
	for i:=imin to imax do
	    if IsDefined(good, i) then
       	        PrintGenerator(fo, i, good[i], false);
	    elif IsDefined(bad, i) then
       	        PrintGenerator(fo, i, bad[i], true);
	    end if;
	end for;
	printf "#T# output: %o\n", Cputime(tp);
end procedure;

// SIDE-EFFECT: fills in GEN with generators of all ideals, good or bad.
// good[i] = x
// bad[i] = <x, ind, deg>
// REQUIRES: "algpr" should have been computed for Kdata.
GeneratorsForPR := procedure(~GEN,Kdata,badidealinfo,algpr,generators)
	K:=Kdata["K"];
        badid:=ReadBadIdeals(K, badidealinfo);	       
	badp:=[x[1] : x in badid];
	printf "# bad ideals=%o\n", badid;
	// read algpr in a table: useful to have in-core?
	ReadAlgpr(~lipr, ~pamax, algpr, DefiningPolynomial(K));
	printf "# pamax = %o\n", pamax;
	printf "# enumerating at %o\n", Cputime();
	l:=EnumeratePrimeNorms(Kdata, lipr, pamax);
//	printf "K:=%m;\nOK:=MaximalOrder(K);\n", K;
//	print l;
	printf "# inspecting at %o\n", Cputime();
	good:=AssociativeArray();
	bad:=AssociativeArray();
	algprimes:=Sort([x : x in Keys(lipr)]);
	BatchGenerators(~good,~bad,generators,Kdata,badp,lipr,l,algprimes);
	GEN["good"]:=good;
	GEN["bad"]:=bad;
end procedure;

// SIDE EFFECT: GEN = {good, bad}
// good[i] = x
// bad[i] = <x, ind, deg>
ReadGeneratorsForPR := procedure(~GEN, K, generators)
	printf "# Reading generators for renumbered ideals from %o\n", 
	       	  generators;
	t:=K.1;
	good:=AssociativeArray();
	bad:=AssociativeArray();
	try
	    fd:=POpen("gzip -dc " * generators, "r");
	catch e
            printf "[%o]\n", e`Object;
            return;
        end try;
	npr:=0;
        while true do
            s:=Gets(fd);
            if IsEof(s) then break; end if;
	    npr:=npr+1;
// if npr gt 50 then break; end if; // for fast debug
	    if npr mod 100000 eq 0 then
	        printf "# reading %o-th generator at %o\n", npr, Cputime();
	    end if;
	    // s = "i -ram_ind ram_deg den x0 ... x_{deg-1}"
	    // or
	    // s = "i den x0 ... x_{deg-1}" with den > 0
	    // x_i are rational integers
	    tmp:=Split(s, " ");
	    i:=StringToInteger(tmp[1]);
	    ind:=StringToInteger(tmp[2]);
	    if ind gt 0 then
	        // ordinary case
		den:=ind;
		ind:=1;
		deg:=1;
		j0:=3;
	    else
	        // a bad ideal
		ind:=-ind;
	        deg:=StringToInteger(tmp[3]);
	    	den:=StringToInteger(tmp[4]);
		j0:=5;
	    end if;
	    x:=0;
	    for j:=j0 to #tmp do
	        x:=x + StringToInteger(tmp[j]) * t^(j-j0);
	    end for;
	    // GEN[i], BAD[i] = <elt_of_K, ...>
	    if j0 eq 3 then
	        good[i]:=x/den;
//		assert IsPrime(Integers()!Norm(good[i]));
		if DLP_DEBUG ge 2 then
	  	    printf "good[%o]=%o (%o)\n", i, good[i], Norm(good[i]);
		end if;
	    else
		bad[i]:=<x/den, ind, deg>;
	    	printf "bad[%o]=%o (%o)\n", i, bad[i], Norm(bad[i][1]);
	    end if;
	end while;
	GEN["good"]:=good;
	GEN["bad"]:=bad;
end procedure;

// now read all ab pairs from purged, together with the ideal numbers
// eps[(a, b)_i] <- unit for (a-b*theta) given its algebraic factorization.
// All that matters is that index i, 1 <= i <= #purged(ab).
// SIDE EFFECT: fills in abunits with "a b v(eps_1) ... v(eps_{rK})"
//              eps[i(ab)] = [v(eps_1), v(eps_2), ..., v(eps_{rK})]
//		we don't care about the valuation of eps_0 (== torsion unit)
UnitsForPurged := procedure(~epsab,abunits,Kdata,GEN,files)
    fu:=Open(abunits, "w");
    iab:=0;
    for fic in files do
	printf "# computing units for relations in %o\n", fic;
	tp:=Cputime();
	K:=Kdata["K"];
	OK:=Kdata["OK"];
	rK:=Kdata["rK"];
	U:=Kdata["UK"];
	t:=K.1;
	good:=GEN["good"];
	bad:=GEN["bad"];

        fd:=POpen("gzip -dc " * fic, "r");
	s:=Gets(fd);
	// read first line: s = "# 10807 37271 10805"
	printf "# first line: %o\n", s;
	nfp:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "-ad21b,8217:4,6,6,c,18,166,1c9,5f4,ad3,1fbc,14,8e,7e7,e23,8d73,0"
	    tmp:=Split(s, ":");
	    tmp2:=Split(tmp[1], ",");
	    a:=StringToInteger(tmp2[1], 16);
	    b:=StringToInteger(tmp2[2], 16);
//	    printf "# s = %o\n", s;
	    if DLP_DEBUG ge 2 then
	        printf "a:=%o; b:=%o;\n", a, b;
//	        printf "a-b*m=%o\n", Factorization(Integers()!(a-b*m));
	    	printf "Norm(a-b*t)=%o\n", Factorization(Integers()!Norm(a-b*t));
		printf "lf = %o\n", Factorization((a-b*t)*OK);
	    end if;
	    tmp2:=Split(tmp[2], ",");
	    // among these, we have rational or algebraic primes
	    li:=[];
	    oldi:=-1;
	    exi:=1;
	    for stri in tmp2 do
	    	i:=StringToInteger(stri, 16);
                sgn := 1;
                if i lt 0 then // strange! FIXME
                    i := -i;
                    sgn := -1;
                end if;
	        if not IsDefined(good, i) and not IsDefined(bad, i) then
		    // i doesn't belong to K
		    continue;
		end if;
		if i eq oldi then
		    exi:=exi+sgn;
		elif oldi ne -1 then
		    li[#li+1]:=<oldi, exi>;
		    exi:=sgn;
                else
                    exi:=sgn;
		end if;
		oldi:=i;
	    end for;
	    if oldi ne -1 then
	        li[#li+1]:=<oldi, exi>;
	    end if;
	    prod:=1;
	    for iexi in li do
	        i,exi:=Explode(iexi);
		if IsDefined(good, i) then
		    if DLP_DEBUG ge 2 then
		        printf "multiplying by good[%o]^e=%o^%o",i,good[i],exi;
		        printf " of norm %o\n", Norm(good[i]);
		    end if;
                    gg := good[i];
                    if exi lt 0 then
                        // Replace gg by its conjugate
                        gg := Evaluate(Polynomial(Eltseq(gg)), 1/t);
                        exi := -exi;
                    end if;
		    prod:=prod * gg^exi;
		elif IsDefined(bad, i) then
                    assert exi gt 0;
		    if DLP_DEBUG ge 2 then
		        printf "multiplying by bad[%o]^e=%o^%o", 
			       i, bad[i][1], exi div bad[i][3];
		        printf " of norm %o\n", Norm(bad[i][1]);
		    end if;
		    prod:=prod * bad[i][1]^(exi div bad[i][3]);
		end if;
	    end for;
	    eta:=((a-b*t)^Kdata["hK"])/prod;
	    if DLP_DEBUG ge 2 then
	        printf "eta[%o, %o]=%o => Norm=%o\n", a, b, eta, Norm(eta);
	    end if;
	    eps,fp:=RecoverUnits(Kdata, OK!eta);
	    iab:=iab+1;
	    epsab[iab]:=eps[2..rK+1];
	    if DLP_DEBUG ge 2 then
	        printf "epsab[%o, %o:%o]=%o\n", a, b, OK!eta, epsab[iab];
	    end if;
	    if epsab[iab] eq [] then error("No unit found"); end if;
	    if fp then nfp:=nfp+1; end if;
	    fprintf fu, "%o %o", a, b;
	    // no need for valuation of eps0
	    for ii:=1 to rK do
	        fprintf fu, " %o", epsab[iab][ii];
	    end for;
	    fprintf fu, "\n";
	end while;
    	printf "#T# units for relations: %o (%o/%o)\n", Cputime(tp), iab, nfp;
    end for;
end procedure;

// File XXX.index
// ==============
// 
// Is is created by replay, and contains the link between the rows of the
// small matrix (coming out from merge/replay) and the relation sets to
// which they correspond.
// 
// The first line gives number of rows (relation-sets) and columns (ideals)
// after the merge/replay.
// 
// Then, each line of the file corresponds to a line of the small matrix:
// the first entry is an integer giving the number of relations in the
// relation-set, and the rest of the line gives the indices of the relations
// (in hexadecimal). These indices relate to the numbers of the lines in the
// purged.gz file.
// 
// For DL, each entry is of the form id:e, where id is the index in the
// purged.gz file, and e is the exponent of the corresponding relation in
// the relation-set.

// Fills in mat with units corresponding to relation sets.
DLProduceUnits := procedure(~mat, purged, index, rK, FB, epsab)
	ab:=DLDumpPurged(purged, true);
        fd:=POpen("gzip -dc " * index, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	small_ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, small_ncols;
	i:=0;
	eps:=[0] cat [0 : j in [1..rK]];
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "3 2c:-1 98:1 a7b:1"
	    tmp:=Split(s, " ");
	    nab:=StringToInteger(tmp[1]);
	    i:=i+1;
	    if i mod 10000 eq 0 then
	        printf "## relation-set %o at %o\n", i, Cputime();
	    end if;
	    for	u:=1 to rK+1 do eps[u]:=0; end for;
	    for k:=1 to nab do
	        // tmp[k+1] = "2c:-1"
		foo:=Split(tmp[k+1], ":");
		id:=1 + StringToInteger(foo[1], 16);
		e :=StringToInteger(foo[2]);
		if ab[id][2] eq 0 then
		    // free relation
		    eta:=FB[ab[id][1]][2];
		    if DLP_DEBUG ge 2 then
		        printf "freerel: %o^e=%o^%o\n", ab[id], eta, e;
		    end if;
		else
		    eta:=epsab[ab[id]];
		    if DLP_DEBUG ge 2 then
		        printf "%o^e=%o^%o\n", ab[id], eta, e;
		    end if;
		end if;
		// update units
		for u:=1 to #eta do
		    eps[u]:=eps[u] + e * eta[u];
		end for;
	    end for;
	    if DLP_DEBUG ge 2 then
	        printf "eps(R%o)=%o\n", i, eps;
	    end if;
	    // we don't care about the valuation of eps0...
	    mat[i]:=eps[2..rK+1];
	end while;
end procedure;

// INPUT: epsab[i] = valuations for (a, b)_i
//                 = [val(eps_1), val(eps_2), ..., val(eps_rK)].
// 	    where i is the i-th relation "a,b:h_0 h_1 ... h_x" in purged.
//	    Note that the espab[i] are also stored in the .units.abunits file.
DLProduceUnits2 := procedure(~mat, purged, index, rK, ~epsab)
	ab:=DLDumpPurged(purged, true);
        fd:=POpen("gzip -dc " * index, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	small_ncols:=StringToInteger(tmp[2]);
	printf "# DLProduceUnits2:";
	printf " small_nrows = %o, small_ncols = %o\n", nrows, small_ncols;
	i:=0;
	eps:=[0 : j in [1..rK]]; // we don't care about val(eps0)
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "3 2c:-1 98:1 a7b:1"
	    tmp:=Split(s, " ");
	    // number of relations in the relation-set
	    nab:=StringToInteger(tmp[1]); 
	    i:=i+1;
	    if i mod 10000 eq 0 then
	        printf "## relation-set %o at %o\n", i, Cputime();
	    end if;
	    for	u:=1 to rK do eps[u]:=0; end for;
	    for k:=1 to nab do
	        // decoding the index of the relation and the power
	        // tmp[k+1] = "2c:-1"
		foo:=Split(tmp[k+1], ":");
		id:=1 + StringToInteger(foo[1], 16);
		e :=StringToInteger(foo[2]);
		tab:=epsab[id];
		if DLP_DEBUG ge 2 then
		    printf "%o: += %o * %o (ab=%o)\n", id, e, tab, ab[id];
		end if;
		// update units
		for u:=1 to rK do
		    eps[u]:=eps[u] + e * tab[u];
		end for;
		// print k, id, e, eps;
	    end for;
	    if DLP_DEBUG ge 2 then
	        printf "eps(R%o)=%o\n", i-1, eps;
	    end if;
	    mat[i]:=eps;
	end while;
end procedure;

// read from .poly
ReadDataFromPolyFile := procedure(~params, name)
	fd:=Open(name, "r");
	f:=0;
	g:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    tmp:=Split(s, " ");
	    if #tmp eq 2 then
	        if tmp[1] eq "n:" then
	            p:=StringToInteger(tmp[2]);
		elif tmp[1][1] eq "c" then
		    // tmp[1] = "c0:"
		    i:=StringToInteger(tmp[1][2]); // humf!
		    f:=f+StringToInteger(tmp[2]) * X^i;
		elif tmp[1][1] eq "Y" then
		    // tmp[1] = "Y0:"
		    i:=StringToInteger(tmp[1][2]); // humf!
		    g:=g+StringToInteger(tmp[2]) * X^i;
		end if;
	    end if;
	end while;
	FpW:=PolynomialRing(GF(p));
	varphi:=Gcd(FpW!Eltseq(f), FpW!Eltseq(g));
	printf "# gcd = %o\n", varphi;
	params["p"]:=p;
	params["f"]:=f;
	params["g"]:=g;
	params["varphi"]:=varphi;
end procedure;

// REM: this might change with future cleaning.
DumpParamsFile := procedure(~params, ficparams)
        fd:=Open(ficparams, "r");
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    tmp:=Split(s, " ");
	    if tmp eq [] then continue; end if;
	    if tmp[1] eq "gorder" then
	        // s = "gorder = 52879981773903133"
		params["ell"]:=StringToInteger(tmp[3]);
	    elif tmp[1] eq "rlim" then
	        params["lim0"]:=StringToInteger(tmp[3]);
	    elif tmp[1] eq "alim" then
	        params["lim1"]:=StringToInteger(tmp[3]);
	    end if;
	end while;
end procedure;

// M will be over Z and sparse
DLReadSmallMatrix := function(small)
        fd:=Open(small, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(fd);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, ncols;
	M:=SparseMatrix();
	i:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "16 2:1 0:1 3:1 4:2 7:1 18:1 36:1 8...."
	    // fill in row_i
	    i:=i+1;
	    tmp:=Split(s, " ");
	    nk:=StringToInteger(tmp[1]);
	    for k:=1 to nk do
	        // tmp[k+1] = "2:1"
		foo:=Split(tmp[k+1], ":");
		j:=1 + StringToInteger(foo[1]);
		SetEntry(~M, i, j, StringToInteger(foo[2]));
	    end for;
	end while;
	return M;
end function;

// We feed the columns [ncols-rK+1..ncols]
DLReadSM := procedure(~M, ficsm, ncols, rK)
        fd:=Open(ficsm, "r");
	// read first line: small_nrows
	s:=Gets(fd);
	nr:=StringToInteger(s);
	assert(nr eq NumberOfRows(M));
	i:=0;
	while true do
	    s:=Gets(fd); if IsEof(s) then break; end if;
	    // s = "26476811979143817355732776187682666169 5914672..."
	    i:=i+1;
	    tmp:=Split(s, " ");
	    for k:=1 to rK do
	        SetEntry(~M, i, ncols-rK+k, StringToInteger(tmp[k]));
	    end for;
	end while;	
end procedure;

DLCheckKernel := function(params, rK)
	printf "# Reading small matrix\n";
	small:=params["small"];
	mat:=DLReadSmallMatrix(small);
	printf "# mat is %o x %o\n", NumberOfRows(mat), NumberOfColumns(mat);
	printf "# Glue-ing sm matrix\n";
	ncols:=NumberOfColumns(mat) + rK;
	DLReadSM(~mat, params["sm"], ncols, rK);
	printf "# Now computing kernel of %o x %o for debug/fun\n",ncols,ncols;
	ker:=NullspaceOfTransposeMatrix(ExtractBlock(mat,1,1,ncols,ncols));
	printf "# kernel is\n%o\n", ker;
	return ker;
end function;

// For i in index, mat[i] should contain the unit contrib to the relation-set.
DLCheckUnitsForRelationSets := procedure(~mat, purged, generators, index, 
			       		       Kdata, ~GEN)
	K:=Kdata["K"];				       
	OK:=Kdata["OK"];				       
	GEN:=AssociativeArray();
	ReadGeneratorsForPR(~GEN, Kdata["K"], generators);		    
	good:=GEN["good"];
	abp:=DLDumpPurged(purged, false);		   
        indf:=POpen("gzip -dc " * index, "r");
	// read first line: small_nrows small_ncols
	s:=Gets(indf);
	tmp:=Split(s, " ");
	nrows:=StringToInteger(tmp[1]);
	small_ncols:=StringToInteger(tmp[2]);
	printf "# small_nrows = %o, small_ncols = %o\n", nrows, small_ncols;
	i:=0;
	while true do
	    s:=Gets(indf); if IsEof(s) then break; end if;
	    // s = "3 2c:-1 98:1 a7b:1"
	    tmp:=Split(s, " ");
	    nab:=StringToInteger(tmp[1]);
	    printf "# nab(%o)=%o\n", i, nab;
	    i:=i+1;
	    eta:=1;
	    for k:=1 to nab do
	        // tmp[k+1] = "2c:-1"
		foo:=Split(tmp[k+1], ":");
		id:=1 + StringToInteger(foo[1], 16);
		e :=StringToInteger(foo[2]);
		ab:=abp[id];
//		printf "ab=%o\n", ab;
		z:=(ab[1]-ab[2]*K.1);
		for j:=3 to #ab do
		    ind:=ab[j];
		    if IsDefined(good, ind) then
		        z:=z/good[ind];
		    end if;
		end for;
		no:=Norm(z);
//		printf "Norm(z)=%o\n", no;
		assert Abs(no) eq 1;
		printf "id=%o: ab=%o e=%o z=%o\n", id, [ab[1], ab[2]], e,
		       RecoverUnits(Kdata, OK!z);
		eta:=eta * z^e;
	    end for;
	    eps:=RecoverUnits(Kdata, OK!eta);
	    printf "eta=%o -> %o // %o\n", eta, eps, mat[i];
//error("TBD");
	end while;
end procedure;

// OUTPUT: if generate then FB,epsab,G,GEN;
UnitsWithParams := function(Kdata, FB, epsab, GEN, generate, params)
	if generate then
	    FB:=AssociativeArray();
	    GEN:=AssociativeArray();
	end if;
//	K<t>:=ext<QQ | f>; // FIXME
//	K:=ext<QQ | params["f"]>; // FIXME
//	Kdata:=PrepareField(K, true); // FIXME
	K:=Kdata["K"];
	rK:=Kdata["rK"];
        if DLP_VERIFICATION then DLCheckKernel(params, rK); end if;
// OBSOLETE
        // space for rK units (we don't care about valuations of units...!)
//	mat:=DLReadSmallMatrix(small, rK, ell);
//      fb:=params["fb"];
//	if generate then // humf!
//	    ReadFactorBase(~FB, K, OK, U, fb, Degree(f));
//	end if;

        purged:=params["purged"];
        generators:=params["generators"];
	if generate then
	    BAD:=AssociativeArray();
	    epsab:=AssociativeArray();
	    if IsDefined(params, "relsdir") then
	        error("Correct this!!!!!");
//	    	TreatFromDir(~FB,~epsab,p,f,g,Kdata,params["relsdir"]);
	    elif IsDefined(params, "algpr") then
	        GeneratorsForPR(~GEN,Kdata,params["badidealinfo"],
				params["algpr"],params["generators"]);
		UnitsForPurged(~epsab,Kdata,~GEN,[purged]);
	    end if;
	    return FB,epsab,GEN,Kdata; // OHHHHHHHHHHHHHHHH!
	else
	    printf "# epsab already computed\n";
	end if;

	U:=Kdata["UK"];
	tp:=Cputime();
	index :=params["index"];
	mat:=[];
	if IsDefined(params, "relsdir") then
 	    DLProduceUnits(~mat, purged, index, Kdata["rK"], FB, epsab);
	else
 	    DLProduceUnits2(~mat, purged, index, Kdata["rK"], ~epsab);
	    if DLP_VERIFICATION then
	        DLCheckUnitsForRelationSets(~mat, purged, generators, index,
						   Kdata, ~GEN);
		UnsetOutputFile();				 
	    end if;
	end if;
	printf "#T# producing units: %o\n", Cputime(tp);
	nrows:=#mat;
	// last cols should be plenty of eps values...!
	ficunits:=params["ficunits"];
	printf "## outputting units to file %o\n", ficunits;
	fd:=Open(ficunits, "w");
	fprintf fd, "%o\n", nrows;
	for i:=1 to nrows do
	    // only rK components, we don't care about val(eps0)
	    for j:=1 to rK do
	        fprintf fd, "%o", mat[i][j];
		if j lt rK then fprintf fd, " "; end if;
	    end for;
	    fprintf fd, "\n";
	end for;
        return [];
end function;

// ell:=63682780151674075656521332710720136307;
// Kdata,FB,epsab,G:=UnitsFromCADO("SNFS", "p59", ell, [], [], [], [], true);
// UnitsFromCADO("SNFS", "p59", ell, Kdata, FB, epsab, G, false);
UnitsFromCADO := function(dir, name, ell, Kdata, FB, epsab, G, GEN, BAD, gen_epsab)
        params:=AssociativeArray();
	if DLP_VERIFICATION then
	    params["small"]:=dir * "/" * name * ".merge.small.txt";
	    params["sm"]:=dir * "/" * name * ".sm.sm";
	end if;
        // "p59"  ===> "SNFS/p59/"
	dir:=dir * "/" * name;
	params["poly"]:=dir * "/" * name * ".polyselect2.poly";

	// not needed, actually
	// fb = "SNFS/p59/p59.factorbase.roots"
	// params["fb"]:=dir * "/" * name * ".factorbase.roots.gz";

        // "p59"  ===> "SNFS/p59/p59.upload/p59"
// 	params["relsdir"]:=dir * "/" * name * ".upload/" * name;
	params["renumber"]:=dir * "/" * name * ".freerel.renumber.gz";
	params["algpr"]:=dir * "/" * name * ".algpr.gz";
	params["generators"]:=dir * "/" * name * ".generators.gz";
	params["purged"]:=dir * "/" * name * ".purge.purged.gz";
	params["index"]:=dir * "/" * name * ".merge.index.gz";
	params["ficunits"]:=dir * "/" * name * ".units.units";
	return UnitsWithParams(Kdata, FB, epsab, GEN, gen_epsab, params);
end function;

// ComputeUnits("SNFS", "p59", 63682780151674075656521332710720136307);
// ComputeUnits("SNFS", "p60-2", 13);
// ComputeUnits("SNFS", "p65d5", 13);
ComputeUnits := procedure(dir, name, ell)
	Kdata,FB,epsab,G,GEN,BAD:=
		UnitsFromCADO(dir,name,ell,[],[],[],[],[],[],true);
	UnitsFromCADO(dir, name, ell, Kdata, FB, epsab, G, GEN, BAD, false);
end procedure;

// If generate = true, we must build algpr and generators.
ComputeUnitsFromWrapper := procedure(polyfile,renumber,algpr,generators,
				     badidealinfo,purged,relsdel,index,
				     ficunits,abunits,usef,generate)

	printf "# usef = %o\n", usef;

        params:=AssociativeArray();

	params["poly"]:=polyfile;
// 	params["relsdir"]:=relsdir;
	params["renumber"]:=renumber;
	params["algpr"]:=algpr;
	params["generators"]:=generators;
	params["badidealinfo"]:=badidealinfo;

	params["purged"]:=purged;
	params["index"]:=index;
	params["ficunits"]:=ficunits;

	if DLP_VERIFICATION then
	    small:=SubstituteString(generators, "generators.gz", 
						"merge.sparse.txt");
	    params["small"]:=small;
//	    params["sm"]:=ficunits;
	    ficsm:=SubstituteString(generators, "generators.gz", "sm.sm");
	    params["sm"]:=ficsm;
	end if;

	FB:=[];
	GEN:=AssociativeArray();
	ReadDataFromPolyFile(~params, params["poly"]);
	if usef then
	    f:=params["f"];
	    K:=ext<QQ | f>;
	    printf "# using f = %o\n", f;
	else
	    g:=params["g"];
	    K:=ext<QQ | g>;
	    printf "# using g = %o\n", g;
	end if;
	Kdata:=PrepareField(K, true); // FIXME
	if generate then
	    GeneratorsForPR(~GEN,Kdata,params["badidealinfo"],
			    params["algpr"],params["generators"]);
	else
	    ReadGeneratorsForPR(~GEN, K, generators);
	    epsab:=AssociativeArray();
	    UnitsForPurged(~epsab,abunits,Kdata,GEN,[purged, relsdel]);
	    UnitsWithParams(Kdata, FB, epsab, GEN, false, params);
	end if;
end procedure;

// Simul("GFP2", "p2dd30", true, true);
// Simul("GFP2", "p277", true, true);
// Simul("../catrel/GFP3", "p3dd10", true, true);
// Simul("../catrel/GFP3", "p3dd10g", true, true);
// Simul("../catrel/GFP2", "p2dd10-f4g2-1mod2-t1--12", true, true);
// Simul("../catrel/GFP", "p37", true, true);
Simul := procedure(dir, name, usef, usegen)
        if DLP_VERIFICATION then
	    SetOutputFile("foo": Overwrite:=true);
 	end if;
	dir:=dir * "/" * name;
	poly:=dir * "/" * name * ".polyselect2.poly";
	renumber:=dir * "/" * name * ".freerel.renumber.gz";
	if usef then
	    algpr:=dir * "/" * name * ".algpr.1.gz";
	    generators:=dir * "/" * name * ".generators.1.gz";
	else
	    algpr:=dir * "/" * name * ".algpr.0.gz";
	    generators:=dir * "/" * name * ".generators.0.gz";
	end if;
	purged:=dir * "/" * name * ".purge.purged.gz";
	relsdel:=dir * "/" * name * ".purge.relsdel.gz";
	index:=dir * "/" * name * ".merge.index.gz";
	ficunits:=dir * "/" * name * ".units.units";
	abunits:=dir * "/" * name * ".units.abunits";
	bad:=dir * "/" * name * ".magmanmbrthry.badidealinfo";

	// FIXME: strange what happens here -> simplify?
	if usegen then
	    printf "# computing generators\n";
	    ComputeUnitsFromWrapper(poly,renumber,algpr,generators,bad,
				    purged,relsdel,index,
				    ficunits,abunits,usef,true);
//error("p277");
	end if;
	printf "# computing units for file %o\n", purged;
	ComputeUnitsFromWrapper(poly,renumber,algpr,generators,bad,
				purged,relsdel,index,ficunits,abunits,
				usef,false);
end procedure;

print "Simul(\"../catrel/GFP3\", \"p3dd15-f4g3-GJL-1\", false, true);";
// Simul("SNFS", "p60x4x4", false);

ComputeUnitsFromWrapper(polyfile,renumber,algpr,generators,badidealinfo,purged,relsdel,index,ficunits,abunits,usef eq "true",ww eq "true"); // don't ask why we should write this...!
exit;
