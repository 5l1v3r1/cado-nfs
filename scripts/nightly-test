#!/usr/bin/env bash
# Usage: nightly-test <MAKE_ARGS>
# If you use this in your crontab, since cron does not have access to
# ssh-agent, a trick is the following:
# 1) run from your home directory: ssh-keygen -N "" -t rsa -f .ssh/cle_gforge
#    This will create a ssh key with empty passphrase in .ssh/cle_gforge,
#    with the public key in .ssh/cle_gforge.pub
# 2) add the content of .ssh/cle_gforge.pub in the list of your ssh keys on
#    gforge.inria.fr (this will be added in authorized_keys)
# 3) add the following lines in your .ssh/config file:
# Host scm.gforge.inria.fr
#    IdentityFile /users/mygroup/mylogin/.ssh/cle_gforge
# 4) you need to add also the lines:
# Host localhost
#    StrictHostKeyChecking no
#    UserKnownHostsFile /dev/null
#    IdentityFile /users/mygroup/mylogin/.ssh/cle_gforge
#    in the .ssh/config file on the computer on which you run nightly-test, and
#    to add the content of cle_gforge.pub in the authorized_keys on that computer.
set -e

cwd=$(cd `dirname $0` ; pwd)

if [ -x "$HOME/cmake/bin/cmake" ] ; then
    echo "Using $HOME/cmake/bin for cmake search path"
    PATH="$HOME/cmake/bin:$PATH"
fi

# Add $HOME/bin unconditionally, for convenience. It's easy to install
# e.g. git in some directory under $HOME, and then have a link from
# there.
PATH="$HOME/bin:$PATH"

nickname=$1
: ${nickname:=`hostname`}


# If the DIR variable is set, then use it as the basename of the temp directory.
if ! [ "$DIR" ] ; then
    DIR=`mktemp -d /tmp/cado-nightly.XXXXXXXX`
else
    /bin/rm -fr "$DIR"
    mkdir "$DIR"
fi

# The following test should be useless, but let's be paranoid.
test ! -h "$DIR"
cd $DIR

# If the USER variable is set, use it instead of the login name for doing
# the checkout.
: ${USER=`whoami`}

# git clone --depth 2 $GIT scm
git clone --depth 2 git://scm.gforge.inria.fr/cado-nfs/cado-nfs.git scm
SCM=scm

# If the cado repository contains a local.sh for this machine, use it.
# Note that this is mandatory even for make dist, since a missing gmp is
# fatal to the cmake process !
if [ -f "$SCM/local.sh.$h" ] ; then
    LOCALFILE="$SCM/local.sh.$h"
elif [ -f "$HOME/local.sh" ] ; then
    LOCALFILE="$HOME/local.sh"
elif [ -f "$cwd/local.sh" ] ; then
    LOCALFILE="$cwd/local.sh"
fi

if [ "$LOCALFILE" ] ; then
    echo "Using $LOCALFILE"
    cp $LOCALFILE "$SCM/local.sh"
else
    echo "Proceeding with no local.sh file"
fi

CADO_DIST_ARCHIVE_NAME=cado-nfs-snapshot-`date +%Y%m%d%H%M`
export CADO_DIST_ARCHIVE_NAME

# first build a tarball
make -C $SCM dist

# now extract the tarball and test it
tar zxf $SCM/$CADO_DIST_ARCHIVE_NAME.tar.gz

if [ "$LOCALFILE" ] ; then
    cp -f $LOCALFILE $CADO_DIST_ARCHIVE_NAME/local.sh
fi

cd $CADO_DIST_ARCHIVE_NAME

# Prepare a ``make install''-ed version. This is a stronger test on
# shared libraries functionality.
export PREFIX="$DIR/installed"

echo -n "Starting compilation at: "
date
if [ "$CC" ] ; then
    make "$@" CC=$CC
else
    make "$@"
fi
make install

if [ "`uname -s`" = Darwin ] ; then
    export DYLD_LIBRARY_PATH="$PREFIX/lib/$CADO_DIST_ARCHIVE_NAME"
    echo "Setting DYLD_LIBRARY_PATH=$PREFIX/lib/$CADO_DIST_ARCHIVE_NAME"
    # TODO: For the moment it does not completely work. Having to set
    # an environment variable for dynamic libraries is a guaranteed
    # failure situation when using -ssh: the enviroment variable does not
    # (cannot) propagate. We should work around this issue.
fi

echo -n "Starting factorization at: "
date
CADO_COLOR=0 $PREFIX/bin/factor.sh 17762929200312168400214710176085810924733654900109067769192140912049 -t 4 -ssh expected_factorization=19,59,3851,836165399,7191239729962900539391,684288898843653097584035467291
CADO_COLOR=0 $PREFIX/bin/factor.sh 4989987986917107645320509935679224561541664588721574446483221849128942141 -t 2 expected_factorization=109,311,143958853,538977678334135295534626724297,1897157801458502657009465237299
CADO_COLOR=0 $PREFIX/bin/factor.sh `$PREFIX/bin/random_integer 57 80` -t 2
rc=$?

if [ "$rc" = 0 ] ; then
    echo OK
    if ! [ "$CADO_DEBUG" ] ; then
        /bin/rm -fr "$DIR"
    fi
else
    echo "FAILED ; data left in $DIR"
fi
