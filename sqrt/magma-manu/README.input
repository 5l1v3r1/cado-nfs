
input/output format for the magma sqrt code.

- The top of sol.m selects the value of several constants, which are
  documented as follows (also in the file)

  * subdir : all data files are loaded from this sub directory.
  * pol : the polynomial (in x of X) defining the number field.
  * N,P : the modulus we're working with, together with a root P of pol mod
    N -- note that N and P are used in a way which seems odd for NFS, as
    indeed we worked with another algorithm for the nfsforge project.
  * fbsize : the number of rational primes that are considered. The
    algebraic factor base is made of prime ideals up to Nthprime(fbsize).
  * e (we're computing e-th roots), which must match the modulus of the
    linear algebra computation that has been performed.
  * block -- the number of simultaneous kernel elements that have been
    computed by the linear algebra step.
  * real_precision (in bits). Precision used for the computation of the
    logarithmic embeddings.


- The file subdir/ur_idl contains information about the easy
  ideals : ideals above p which are unramified and not dividing lc(pol).
  (the other ideals are recovered directly from magma).
  The file contains 3 integers per line, named p, r, and x. Such a triple
  describes the ideal generated by p and alpha-r (alpha is the root of
  pol).
  In the example, r is given to higher precision, such that r is a root
  of pol mod p^x ; however it's not used for the sqrt.

  subdir/ur_idl is read from setup.m

- The ordering of the factor base ideals matters. ``special'' ideals are
  computed by the magma code, ordered by magma hash value, and we
  eventually consider the factor base formed by these special ideals in
  order, + the ideals from ur_idl in reading order. The matrix step must
  reflect this ordering.

  In particular, ideals that never appear must at least still appear in a
  pre-pruning version of the matrix, say matrix.txt.ur . In this way, we
  can reproduce the ideal valuation vectors corresponding to the magma
  ordering.

- The file subdir/clink.txt contains the (a,b) information for the relations
  involved in the linear algebra computation. For reasons pertaining to
  the problem for which this code was originally used, the information
  has to be specified as a quadruple (q,r,x,b) such that the ideal
  factorization considered is that of a-b*alpha, with a=r+q*x

  subdir/clink.txt is read from sol0.m

- The files subdir/W00 to subdir/W0$XX (where XX=block-1) are kernel
  vectors for the row dependencies. The vectors are expected to be files
  of N lines, with only one integer per line (either between -e/2 and
  e/2, or 0 and e-1).

  subdir/W00 and so on are read from sol0.m

- The files subdir/W00.mul to subdir/W0$XX.mul contain the result of the
  multiplication of the *unreduced* matrix by the kernel elements. The
  unreduced matrix has coefficients in Z, and has all factor base ideals
  appearing in rows, in the exact order magma expects them. The reduced
  matrix might discard these rows, but the W0X.mul files must have them
  The W0X.mul vectors must have as many coordinates as factor base
  elements, and will give the valuation of the combined product at each
  ideal in the factor base. By construction, the coordinates of these
  vectors must be divisible by e.

  subdir/W00.mul and so on are read from sol0.m

- subdir/characters contains character values for each of the
  algebraic integers in subdir/clink.txt ; we don't care which kind of
  characters are used, nor how many of them are used.
  subdir/characters must contain exactly as many lines as
  subdir/clink.txt, and each line must have the same number of integers
  modulo e, corresponding to the computed characters.

  subdir/characters is read from sol0.m

- [unused] subdir/complete contains information about the raw relation
  factorizations, which are used to check if the ideal ordering is right.
  It is used in icheck.m is commented out as it would be cumbersome to
  handle here.


- In the end, the program computes the mapping of the algebraic e-th
  root to Z/NZ, by evaluating at P. This mapping is the last integer
  printed.
