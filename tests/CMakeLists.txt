# The SRCFILE parameter to this macro is the file name of the source file to
# build. The LIBRARIES parameter is any libraries that should be linked in.
# Any additional parameters are added to the command line of the test
# executable that gets run.
macro(build_and_run_test SRCFILE LIBRARIES)

    # The name of the binary executable is equal to the name of the source
    # file, minus the extension
    get_filename_component (DSTFILE "${SRCFILE}" NAME_WE)

    # Add a build target for the test binary
    add_executable("${DSTFILE}" "${SRCFILE}")
    target_link_libraries("${DSTFILE}" ${LIBRARIES})

    # This add_test() call causes the ctest program to be called on the
    # current source and binary directories. The ctest program then builds
    # the DSTFILE binary by calling cmake (which we suppress here) and make,
    # and then runs DSTFILE
    add_test ("${DSTFILE}" "${CMAKE_CTEST_COMMAND}"
              # Specify the source and build directories for the Cmake/make
              # steps that gets executed by CTest (except we suppress the
              # CMake step in this CTest run, but we still have to specify the
              # directories)
              --build-and-test "${CMAKE_CURRENT_SOURCE_DIR}"
                               "${CMAKE_CURRENT_BINARY_DIR}"

              # If CTest were to run Cmake, it should use same CMake generator
              # as we use in the parent Cmake. We suppress the CMake call, but
              # the "--build-generator" parameter is mandatory so we have to
              # specify it anyway. Without it, we get this error:
              # "--build-and-test requires that both the generator and 
              #  makeprogram be provided using the --build-generator and 
              #  --build-makeprogram command line options."
              --build-generator "${CMAKE_GENERATOR}"

              # Use same make program as the parent CMake.
              --build-makeprogram "${CMAKE_MAKE_PROGRAM}"

              # Do NOT run CMake. The CMakeCache.txt file generated by having
              # add_subdirectory() in the parent directories is fine, and
              # if we were to let CTest re-run CMake, we'd have to figure out
              # directory locations all over again - this way, we inherit
              # everything from the CMakeCache.txt generated by the parent
              # CMake.
              --build-nocmake

              # Normally, CTest runs "make clean" before building any target,
              # so that only the most recently built target would remain in
              # the build directory. I assume we don't want that, but want to
              # be able to run them manually as well. Do tell CTest not to do
              # "make clean."
              --build-noclean

              # When we build and run this test, build only the binary
              # required for this test
              --build-target "${DSTFILE}"

              # If any test fails, print its output to stdout.
              # ... except that does not actually work. When running the
              # test suite with
              # /usr/bin/ctest --force-new-ctest-process -V
              # then the debugging output shows --output-on-failure being
              # passed to the spawned ctest processes, but without -V, they
              # still don't print anything in case of failure. Maybe a bug.
              # To get output, we have to pass it via ARGS to "make test".
              --output-on-failure

              # And finally the binary that should be run as the actual test
              --test-command "${DSTFILE}" ${ARGN})
endmacro(build_and_run_test)

include_directories("${CMAKE_CURRENT_SOURCE_DIR}")
add_library (tests STATIC test_iter.c)

add_subdirectory (utils)
