#include <stdlib.h>

#include "latsieve.h"
#include "types.h"
#include "ijvec.h"
#include "sublat.h"



// We are going recursive, here, so let's try not to have too many
// parameters to be passed, since they might end-up being pushed/popped
// a lot of times.

typedef struct {
    ijvec_t V;
    int I;
    int J;
    uint8_t *S;
    ijbasis_srcptr basis;
    fbideal_ptr    gothp;
} vvs_param_t;


static inline void handle_V(vvs_param_t *vvsp) {
    if (!ij_is_monic(vvsp->V->j) && vvsp->V->j!=0)
        return;
    ijpos_t pos = ijvec_get_pos(vvsp->V, vvsp->I, vvsp->J);
#ifdef TRACE_POS
    if (pos == TRACE_POS) {
        fprintf(stderr, "TRACE_POS(%lu): ", pos);
        fbprime_out(stderr, vvsp->gothp->p); fprintf(stderr, " ");
        fbprime_out(stderr, vvsp->gothp->r); fprintf(stderr, "\n");
        fprintf(stderr, "TRACE_POS(%lu): degnorm is now %d\n", pos,
                vvsp->S[pos]-vvsp->gothp->degp);
    }
#endif
    if (pos != 0 && (vvsp->S[pos] < vvsp->gothp->degp)) {
        fprintf(stderr, "faulty pos is %lu\n", pos);
    }
    ASSERT(pos == 0 || (vvsp->S[pos] >= vvsp->gothp->degp));
    vvsp->S[pos] -= vvsp->gothp->degp;
}

// visit the affine vector space V + generated by base vectors [0..k-1]
// V is changed during the execution, but is put back to its value before
// return.
void visit_vector_space(vvs_param_t *vvsp, unsigned int k) {
    // TODO: is it better to store the orig value to save an add ?
    // In charact 2, certainly not, but in charact 3, probably yes.
    
    // Unrolled small cases
    if (k == 3) {
        for (int i = 0; i < FP_SIZE; ++i) {
            for (int i = 0; i < FP_SIZE; ++i) {
                for (int i = 0; i < FP_SIZE; ++i) {
                    handle_V(vvsp);
                    ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[0]);
                }
                ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[1]);
            }
            ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[2]);
        }
        return;
    }
    if (k == 2) {
        for (int i = 0; i < FP_SIZE; ++i) {
            for (int i = 0; i < FP_SIZE; ++i) {
                handle_V(vvsp);
                ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[0]);
            }
            ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[1]);
        }
        return;
    }
    if (k == 1) {
        for (int i = 0; i < FP_SIZE; ++i) {
            handle_V(vvsp);
            ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[0]);
        }
        return;
    }
    if (k == 0)
        return;

    // Other cases, using recursivity 
    visit_vector_space(vvsp, k-1);
    for (int i = 1; i < FP_SIZE; ++i) {
        ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[k-1]);
        visit_vector_space(vvsp, k-1);
    }
    ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[k-1]);
}

// In the case of sublattices, compute the starting point for the sieve
// by gothp for the current sublattice.
// If there is no starting point return 0.
static int compute_starting_point(ijvec_ptr V0, fbideal_srcptr gothp,
                                  sublat_ptr sublat)
{
    if (!use_sublat(sublat)) {
        ijvec_set_zero(V0);
        return 1;
    }
    // TODO: Way too expensive!
    // xi and yi have degree 2
    ij_t xi, xip, yip;
    ij_set_16(xi, sublat->lat[sublat->n][0]);
    fbprime_t tmp0;
    ij_t tmp1;
    fbprime_set_16(tmp0, sublat->lat[sublat->n][1]);
    fbprime_mulmod(tmp0, gothp->lambda, tmp0, gothp->p);
    ij_set_fbprime(yip, tmp0);
    ij_add(xip, xi, yip);
    ij_set_16(tmp1, sublat->modulus);
    ij_mulmod(xip, xip, gothp->tildep, tmp1);
    ij_set_fbprime(tmp1, gothp->p);
    ij_mul(V0->i, xip, tmp1);
    ij_add(V0->i, V0->i, yip);

    ij_t ijmod;
    ij_set_16(ijmod, sublat->modulus);
    ij_sub(V0->i, V0->i, xi);
    ij_div(V0->i, V0->i, ijmod);
    ij_set_zero(V0->j);
    return 1;
}

// FIXME: Multiplication is not compatible with lexicographical order, so there
// is no guarantee that we visit lines by increasing j's.
// However, since the positive-j part of the basis of the GF(p)-vector-space is
// (0, p*t^k) for 0 <= k < J-deg(p), and since this basis is independent from
// the special-Q or the sublattice, we can precompute a reduced row-echelon
// form of this basis for all small primes while reading the factor bases.
// Then, a simple enumeration via a p-ary monic Gray code should nicely do the
// trick (TODO!).
#if 0
void sieve_projective_root(uint8_t *S, fbideal_ptr gothp, unsigned I,
                           unsigned J, ijpos_t pos0, ijpos_t size,
                           sublat_ptr sublat)
{
    ASSERT(gothp->degp < I);
    ij_t i, j, jj, p;
    ij_set_fbprime(p, gothp->p);

    // First time round?
    if (UNLIKELY(!pos0)) {
      // Find the first line to fill
      if (use_sublat(sublat)) {
        // take the first multiple of p that is congruent to y.
        ij_t tmp, y;
        ij_set_16(tmp, sublat->modulus);
        ij_set_16(y, sublat->lat[sublat->n][1]);
        ij_mulmod(gothp->j0, y, gothp->tildep, tmp);
        ij_mul   (gothp->j0, gothp->j0, p);
        // map it into the sublattice.
        ij_sub(gothp->j0, gothp->j0, y);
        ij_div(gothp->j0, gothp->j0, tmp);
      } else {
        ij_set_zero(gothp->j0);
      }
      ij_set_zero(gothp->j);
    }

    int rci, rcj = 1;
    for(ij_set(jj, gothp->j); rcj;
        rcj = ij_monic_set_next(jj, jj, J-gothp->degp)) {
        ij_mul(j, jj, p);
        if (use_sublat(sublat))
            ij_add(j, j, gothp->j0);
        if (start >= size)
          break;
        rci = 1;
        for (ij_set_zero(i); rci; rci = ij_set_next(i, i, I)) {
            ijpos_t pos = start + ijvec_get_offset(i, I);
#ifdef TRACE_POS
            if (pos == TRACE_POS) {
                fprintf(stderr, "TRACE_POS(%lu): ", pos);
                fbprime_out(stderr, gothp->p); fprintf(stderr, " ");
                fbprime_out(stderr, gothp->r); fprintf(stderr, "\n");
                fprintf(stderr, "TRACE_POS(%lu): degnorm is now %d\n", pos,
                        S[pos]-gothp->degp);
            }
#endif
#ifndef NDEBUG
            if (pos != 0 && (S[pos] < gothp->degp)) {
                fprintf(stderr, "faulty pos is %lu\n", pos);
            }
            ASSERT(pos == 0 || (S[pos] >= gothp->degp)); 
#endif
            S[pos] -= gothp->degp;

        }
    }
    ij_set(gothp->j, jj);
}
#endif

void sieveFB(uint8_t *S, factor_base_srcptr FB, unsigned I, unsigned J,
             ij_t j0, ijpos_t pos0, ijpos_t size, sublat_ptr sublat)
{
  ijbasis_t basis;
  ijbasis_t euclid;
  int hatI, hatJ;
  hatI = I + sublat->deg;
  hatJ = J + sublat->deg;

  ijbasis_init(basis, I, J);
  ijbasis_init(euclid, hatI, hatJ);

    for (unsigned int ii = 0; ii < FB->n; ++ii) {
        fbideal_ptr gothp = FB->elts[ii];
        int L = gothp->degp;
        // Larger primes are left to the bucket sieve.
        if ((unsigned)L >= I) break;
        // List of cases that are not handled yet:
        if (use_sublat(sublat) && L == 1) continue;

        // projective roots are handled differently
        if (gothp->proj) {
            // FIXME: For the time being, projective-root sieving is disabled.
            // See above for an explanation why.
            // sieve_projective_root(S, gothp, I, J, pos0, size, sublat);
            continue;
        }


        ijbasis_compute(euclid, basis, gothp);
        ijvec_t V0;
        if (use_sublat(sublat)) {
            int st = compute_starting_point(V0, gothp, sublat);
            if (!st)
                continue; // next factor base prime.
        } else {
            ijvec_set_zero(V0);
        }

        //******************************************************************
        // visit this vector space and subtract the contribution of
        // gothp in the corresponding position in S.
        vvs_param_t vvs;
        vvs.I = I;
        vvs.J = J;
        vvs.S = S;
        vvs.basis = basis;
        vvs.gothp = gothp;
        ijvec_set(vvs.V, V0);
        visit_vector_space(&vvs, basis->dim);
    }

    ijbasis_clear(euclid);
    ijbasis_clear(basis);
}
