#include <stdlib.h>

#include "latsieve.h"
#include "types.h"
#include "ijvec.h"



// We are going recursive, here, so let's try not to have too many
// parameters to be passed, since they might end-up being pushed/popped
// a lot of times.

typedef struct {
    ijvec_t V;
    int I;
    int J;
    uint8_t *S;
    ijbasis_srcptr basis;
    fbideal_srcptr gothp;
} vvs_param_t;


static inline void handle_V(vvs_param_t *vvsp) {
    if (!ij_is_monic(vvsp->V->j) && vvsp->V->j!=0)
        return;
    ijpos_t pos = ijvec_get_pos(vvsp->V, vvsp->I, vvsp->J);
#ifdef TRACE_POS
    if (pos == TRACE_POS) {
        fprintf(stderr, "TRACE_POS(%d): ", pos);
        fbprime_out(stderr, vvsp->gothp.p); fprintf(stderr, " ");
        fbprime_out(stderr, vvsp->gothp.r); fprintf(stderr, "\n");
        fprintf(stderr, "TRACE_POS(%d): degnorm is now %d\n", pos,
                vvsp->S[pos]-vvsp->gothp->degp);
    }
#endif
    if (pos != 0 && (vvsp->S[pos] < vvsp->gothp->degp)) {
        fprintf(stderr, "faulty pos is %u\n", pos);
    }
    ASSERT(pos == 0 || (vvsp->S[pos] >= vvsp->gothp->degp));
    vvsp->S[pos] -= vvsp->gothp->degp;
}

// visit the affine vector space V + generated by base vectors [0..k-1]
// V is changed during the execution, but is put back to its value before
// return.
void visit_vector_space(vvs_param_t *vvsp, unsigned int k) {
    // TODO: is it better to store the orig value to save an add ?
    // In charact 2, certainly not, but in charact 3, probably yes.
    
    // Unrolled small cases
    if (k == 3) {
        for (int i = 0; i < FP_SIZE; ++i) {
            for (int i = 0; i < FP_SIZE; ++i) {
                for (int i = 0; i < FP_SIZE; ++i) {
                    handle_V(vvsp);
                    ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[0]);
                }
                ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[1]);
            }
            ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[2]);
        }
        return;
    }
    if (k == 2) {
        for (int i = 0; i < FP_SIZE; ++i) {
            for (int i = 0; i < FP_SIZE; ++i) {
                handle_V(vvsp);
                ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[0]);
            }
            ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[1]);
        }
        return;
    }
    if (k == 1) {
        for (int i = 0; i < FP_SIZE; ++i) {
            handle_V(vvsp);
            ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[0]);
        }
        return;
    }
    if (k == 0)
        return;

    // Other cases, using recursivity 
    visit_vector_space(vvsp, k-1);
    for (int i = 1; i < FP_SIZE; ++i) {
        ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[k-1]);
        visit_vector_space(vvsp, k-1);
    }
    ijvec_add(vvsp->V, vvsp->V, vvsp->basis->v[k-1]);
}



void sieveFB(uint8_t *S, factor_base_srcptr FB, unsigned I, unsigned J)
{
  ijbasis_t basis;
  ijbasis_init(basis, I, J);

    for (unsigned int ii = 0; ii < FB->n; ++ii) {
        fbideal_srcptr gothp = FB->elts[ii];
        if (gothp->proj) continue;
        ijbasis_compute(basis, gothp);

        //******************************************************************
        // visit this vector space and subtract the contribution of
        // gothp in the corresponding position in S.
#if FP_SIZE == 2
        // TODO: quadratic version, specific to char 2. Please improve!
        for (unsigned int k = 0; k < (1U<<basis->dim); ++k) {
            // at some point, we might deal with *affine* spaces.
            // In that case, just change the initial value of V.
            ijvec_t V = {{ {0}, {0}}};  
            unsigned int l = k;
            for (unsigned i = 0; i < basis->dim; ++i, l>>= 1)
                if (l & 1U)
                    ijvec_add(V, V, basis->v[i]);
            /*
            printf("vec %u: ", k);
            ij_out(stdout, V->i);
            printf(" ");
            ij_out(stdout, V->j);
            printf("\n"); */

            ijpos_t pos = ijvec_get_pos(V, I, J);
#ifdef TRACE_POS
            if (pos == TRACE_POS) {
                fprintf(stderr, "TRACE_POS(%d): ", pos);
                fbprime_out(stderr, gothp->p); fprintf(stderr, " ");
                fbprime_out(stderr, gothp->r); fprintf(stderr, "\n");
                fprintf(stderr, "TRACE_POS(%d): degnorm is now %d\n", pos,
                        S[pos]-gothp->degp);
            }
#endif
            if (pos != 0 && (S[pos] < gothp->degp)) {
                fprintf(stderr, "faulty pos is %u\n", pos);
            }
            ASSERT(pos == 0 || (S[pos] >= gothp->degp)); 
            S[pos] -= gothp->degp;
        }
#else   // FP_SIZE != 2
        vvs_param_t vvs;
        vvs.I = I;
        vvs.J = J;
        vvs.S = S;
        vvs.basis = basis;
        vvs.gothp = gothp;
        ij_set_zero(vvs.V->i);
        ij_set_zero(vvs.V->j);
        visit_vector_space(&vvs, basis->dim);
#endif
    }

    ijbasis_clear(basis);
}
