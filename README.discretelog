This file explains how to use the discrete log (DL) possibilities of
CADO-NFS. It is possible to deal with finite fields of one of the three
following forms:
  - prime fields
  - finite fields of characteristic 2   
  - finite fields of characteristic 3

Discrete logs in prime fields are computed with the number field sieve
(NFS), whereas in fields of small characteristic, the function field
sieve (FFS) is implemented.

There is no general script (yet!) for computing discrete logs
automatically. We describe here the sequence of steps to be performed. 
It is assumed that the user has some background knowledge on the
algorithm.

DL in prime fields (NFS-DL)
===========================

Notation:
  p:    we want to compute discrete logs in GF(p)
  ell:  a prime factor of p-1; we compute logs modulo ell.
        ell should be large enough (otherwise, use another algorithm)

- polynomial selection: use the same as for factorization. In fact, you
  can just pretend that you want to factor p, and get the polynomial that
  is automatically selected by the cadofactor script.

  There is also an experimental implementation of the Joux-Lercier
  construction with 2 non-linear polynomials: polyselect/dlpolyselect.c

- relation collection:
  Factor base construction and relation collection is exactly the same as
  for factorization.

- free relation / renumbering of ideals:
  This starts to differ. The freerel.c binary needs additional
  information compared to factorization.
  Indeed, it is important that the representation of a relation in the
  matrix follows precisely the factorization into ideals, including for
  bad primes p that divides the discriminant and/or the leading
  coefficient.
  Furthermore, it might be necessary to add a column of 1 to deal with
  leading coefficients.

- filtering:
  - dup1 works the same way as for factorization
  - dup2 needs the -dl parameter, so that it does not reduce the
    exponents mod 2
  - purge works the same way as for factorization
  - use merge-dl instead of merge
  - use replay-dl instead of replay
  NB: there is also a script in the ffs/filter/ directory that is
  supposed to do all these steps automatically.

- Schirokauher maps:
  Must be computed before the linear algebra, using the linalg/sm binary.
  Takes ell (= group order) and smexp as parameters (and obvious file
  names coming out from the filtering).
  smexp is the LCM(ell^k_i-1), where k_i takes all the degrees of the
  factors of f(x) modulo ell. (this will be computed automatically
  someday)

- Linear algebra:
  This is highly experimental.
  Some hints about how to play is in
     linalg/bwc/bwc-ptrace.sh
  Following the steps here might allow you to call a very basic and very
  slow block-Wiedemann implementation. Be aware that this does not
  include code for gluing together the filtered matrix and the SM
  columns.  We have more efficient code that will be added in due time,
  and then the scripts will be enhanced. In the meantime, you are on your
  own... Note that depending on the size of ell, using this code may
  entail recompiling by changing the plingen_prime_nwords variable in the
  file linalg/bwc/CMakeLists.txt, or worse, re-generate the code lin
  linalg/bwc/Makefile.mpfq

- Reconstruct dlogs of fb elements
  Nothing automatic here, but in filter/reconstructlog.c you will find
  some tool to help you.

- Individual logarithms
  sieve/las is able to perform the special-q descent.
  For that it needs to be recompiled with DLP_DESCENT and SUPPORT_LARGE_Q
  (see las-config.h).
  Again, nothing is automatic, here.

DL in characteristic 2 or 3 (FFS)
=================================

Notation:
  p, n:   we want to compute dlog in GF(p^n), with p=2 or p=3.
  
You should first compile the FFS-related binaries. Visit the ffs/
subdirectory, copy Makefile.local.example to Makefile.local and edit it
to configure according to what you want; then type 'make'.

- polynomial selection:
  Nothing automatic. There are some tools in the polyselect subdirectory.
  The code presently assumes that curves with only one place at infinity
  are chosen.

- relation collection:
  Create a parameter file, imitating the ones in the ffs/params/
  directory.
  Then run
    ffs/f2/makefb <paramfile>
  or 
    ffs/f3/makefb <paramfile>
  depending if you are in characteristic 2 or 3. From now on, we assume
  characteristic 2.

  Computing relations is done with
    ffs/f2/sieve <paramfile>
  You'll have to deal by yourself with the special-q ranges, and so on.

- freerels/filtering
  The script ffs/filter/filter.sh is available for doing all this step.
  (like for NFS-DL, bad ideals must be taken care in a way or antoher,
  and it is up to you; nothing automatic yet). No Schirokauer maps are
  needed here.

- Linear algebra:
  Exactly the same as for NFS-DL

- Reconstruct dlogs of fb elements
  The same as for NFS-DL
  
- Individual logarithms
  Nothing automatic. Use ffs/descent_init and ffs/sieve to do the
  descent.
