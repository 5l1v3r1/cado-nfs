
params.c is good for having your program parse key/value options. Common
syntaxes accepted are --foo blah, -foo blah, or foo=blah. On a first
pass, keys are recognized as strings, and parsing comes later on once
lexing has completed.

``knobs'' is the term I use for option which trigger something by their
mere presence, not requiring any other ``value'' input. The archetypal
example is for example --verbose.

``aliases'' is a means of indicating that a given option may be
referenced in more than one manner.

Effort has been put towards making it possible and easy to source a
config file hosting a (possibly large) number of options.



To use params.[ch], your main() function must follow the following
pattern.

    param_list pl;

    param_list_init(pl);

    argv++,argc--;
    /* knobs, if any. See below */
    /* aliases, if any. See below */

    for( ; argc ; ) {
        if (param_list_update_cmdline(pl, &argc, &argv)) { continue; }
        /* Do perhaps some other things on the argument that haven't
         * been eaten at all. Like check whether it is a valid file to
         * source in order to get more options. See
         * param_list_read_stream and param_list_read_file for that. */
        fprintf (stderr, "Unknown option: %s\n", argv[0]);
        usage();
    }

    /* Now parse the values corresponding to options, and map their
     * meaning somewhere */
    const char * tmp;

    /* param_list_lookup_string gives a const char * pointer which will
     * live only for as long as the param_list structure isn't freed. The
     * return value is NULL if no such key exists */

    if ((tmp = param_list_lookup_string(pl, "subdir")) != NULL) {
        fprintf(stderr, "--subdir is no longer supported."
                " prepend --out with a path instead.\n");
        exit(1);
    }

    /* ... */

    /* It is possible to strdup() it of course */
    working_filename = strdup(param_list_lookup_string(pl, "out"));
    if (working_filename == NULL) {
        fprintf(stderr, "Required argument --out is missing\n");
        exit(1);
    }
    /* ... */


    /* all parsing functions return 1 when the key was found, 0 if not.
     * If no key was found, no assignment is performed and the default
     * value set beforehand remains */
    param_list_parse_int(pl, "hslices", &split[0]);
    param_list_parse_int(pl, "vslices", &split[1]);

    int split[2] = {1,1};
    param_list_parse_intxint(pl, "nbuckets", split);

    /* Good practice mandates that unused parameters trigger a warning,
     * if not an error. Only unused parameters from command line are
     * considered for issuance of a warning. Unused parameters found in
     * config files are considered normal and trigger nothing.
     */
    if (param_list_warn_unused(pl)) {
        usage();
    }
    param_list_clear(pl);


It is also possible to configure knobs. Configure knobs goes toghether
with specifying a pointer to the knob value, which must have type int.

    param_list_configure_knob(pl, "--legacy", &legacy);
    param_list_configure_knob(pl, "--remove-input", &remove_input);
    param_list_configure_knob(pl, "--pad", &pad_to_square);

Aliases:
    param_list_configure_alias(pl, "--pad", "--square");
    // --> means that the knob --pad may be aliased as --square

    param_list_configure_alias(pl, "out", "output-name");
    // means that --out, out=, and so on, may be aliased as
    // --output-name, etc.


There is some more documentation text in params.h
